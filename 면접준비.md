# Part 1. 전산 기초

## 💡 개발상식 [Link](https://github.com/JaeYeopHan/Beginner_for_interview/tree/master/Development_common_sense)

- ### 객체 지향 프로그래밍이란 무엇인가?

  객체지향 프로그래밍은 프로그래밍을 명령어 또는 함수의 목록으로 보는 명령형 프로그래밍의 절차지향적 관점에서 벗어나 **프로그램을 여러개의 독립적 객체들의 집합으로 표현**하려는 프로그래밍 패러다임을 말한다.
  

  #### 객체 지향 프로그래밍의 4가지 원칙

  - 추상화 (abstraction) : 다양한 속성 중에서 프로그램에 필요한 속성만을 간추려내어 표현하는 것을 추상화라고 한다. 불필요한 정보는 숨기고 필요한 정보만을 표현함으로써 공토
  - 캡슐화 (encapsulation) : 모든 객체가 자신의 상태(state, private variavles)를 클래스 내부에 private으로 보유함으로써 지켜진다. 내부 상태를 내부 메소드로만 접근할 수 있게 한다.
  - **상속 (inheritance)** : 객체지향 프로그래밍의 핵심 개념으로 부모 객체의 프로퍼티를 자식 개체가 상속받아 그대로 사용할 수 있는 것을 말한다.
  - 다형성 (polymorpism) : 부모 객체가 선언한 interface 메소드를 자식 객체가 재정의(overiding) 함으로써 하나의 interface로 상황에 따라 기능을 달리 하는 것을 말한다.

  ###### Function OverLoading : 이름은 같지만 signature(parameter 수, data type)는 다른 method를 중복으로 선언하는 것

  method 이름은 같아야 한다. Parameter 수는 달라야 하며, 같다면 data type이 달라야 한다.

  ###### Method OverRiding : 부모 클래스의 method 동작 방법을 재정의하여 우선적으로 사용하는 것.

  override 하고자 하는 method가 상위 클래스에 존재해야 한다. Method 이름이 같아야 하며, parameter 개수, data type, return type 등 모든 signature를 동일하게 사용한다. 달라지는 것은 내부 구현 뿐이다.

  부르는 object만 달라질뿐 method 이름을 동일하게 하면 하나의 method로 여러 기능을 실행할 수 있다.

  #### 객체 지향적 설계 원칙

  1. **S**RP(Single Responsibility Principle) : 단일 책임 원칙
     클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
  2. **O**CP(Open-Closed Principle) : 개방-폐쇄 원칙
     확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
  3. **L**SP(Liskov Substitution Principle) : 리스코프 치환 원칙
     상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
  4. **I**SP(Interface Segregation Principle) : 인터페이스 분리 원칙
     “특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.”
  5. **D**IP(Dependency Inversion Principle) : 의존 역전 원칙
     고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

  

- ### RESTFul API 란?

  REST란 REpresentational State Transfer의 약자로 RESTful API란 REST의 기본 원칙에 충실한 서비스 디자인이다.

  #### 1. REST API 중심 규칙

  ##### 1) URI는 정보의 자원을 표현해야 한다.

  리소스명으로 동사보다는 명사를 사용

  URI는 자원을 표현하는 데 중점 두어야 함

  ##### 2) 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)로 표현한다.

  ```
  # bad
  GET /books/delete/1
  
  # good
  DELETE /books/1
  ```

  #### 2. HTTP Method

  주로 5자리 Method를 사용해서 **CRUD** (Create, Read, Update, Delete) 구현

  | Method | Action         | 역할                  |
  | :----- | :------------- | :-------------------- |
  | GET    | index/retireve | 모든/특정 리소스 조회 |
  | POST   | create         | 리소스 생성           |
  | PUT    | update all     | 모든 리소스 갱신      |
  | PATCH  | update         | 리소스 갱신           |
  | DELETE | delete         | 리소스 삭제           |

  #### 3. Configuring the REST API

  ##### REST의 3요소

  | 구성 요소       | 내용                            | 표현 방법                 |
  | :-------------- | :------------------------------ | :------------------------ |
  | Resource        | Resource                        | HTTP URI                  |
  | Verb            | Actions on Resources            | HTTP Method               |
  | Representations | Details of actions on resources | HTTP Message **Pay Load** |

  REST는 Self-descriptiveness(자체 표현 구조)로 구성되어 REST API만으로 Request를 이해할 수 있다.

  

- ### TDD 란 무엇이며 어떠한 장점이 있는가?

  Test-Driven Development(TDD)는 **매우 짧은 개발 사이클의 반복**에 의존하는 소프트웨어 개발 프로세스이다. 개발자는 우선 새로운 요구사항에 대한 자동화된 테스트케이스를 작성하고, 해당 테스트를 통과하는 가장 간단한 코드를 작성한다. 일단 테스트를 통과하면 상황에 맞게 리팩토링하는 과정을 거친다. Test-Driven의 말 뜻 그대로 테스트가 코드 작성을 주도하는 개발 방식이다.

  #### 테스트 추가

  TDD에서는 새로운 기능을 추가하기 전에 테스트를 먼저 작성한다. 테스트 작성을 위해서는 기능의 요구사항과 명세를 분명히 이해하고 있어야한다.

  #### 모든 테스트 수행하고 실패하는 것 찾기

  새로운 기능을 추가하면 잘 작동하던 기능이 제대로 작동하지 않을 수 있으므로 테스트 코드를 작성함으로써 새로운 기능이 제대로 작동함과 동시에 기존 기능이 유지되는지 테스트를 통해 확인한다.

  #### 코드 리팩토링

  

- ### 함수형 프로그래밍이란?

  #### 함수형 프로그래밍의 가장 큰 특징 2가지

  - immutable data
  - first class citizen으로서의 function

  #### immutable

  immutable이란 말 그래도 변경 불가능한 것으로, immutable 객체란 원래 자바스크립트의 mutable한 객체와 달리 객체 내부의 내용을 직접 변경하지 않고 새로운 객체를 생성하여 재할당을 통해서만 변경하는 객체를 말한다.

  #### first-citizen

  함수형 프로그래밍 패러다임에서의 함수는 일급 객체로(first class) 간주된다.

  아래와 같은 조건을 만족하는 객체를 **일급 객체**([first-class object](https://ko.wikipedia.org/wiki/일급_객체))라 한다.

  1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
  2. 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.
  3. 함수의 매개 변수에게 전달할 수 있다.
  4. 함수의 결과값으로 반환할 수 있다.

  #### Reactive Programming

  반응형 프로그래밍은 선언형 프로그래밍이라고도 불리며 명령형 프로그래밍의 반댓말이다. 반응형 프로그래밍은 함수형 프로그래밍 패러다임을 활용하는 것을 말한다.

  - Reactive Programing은 기본적으로 **모든 것을 스트림(stream)**으로 본다. 이벤트, ajax call, 등 모든 데이터의 흐름을 시간순서에 의해 전달되어지는 스트림으로 처리한다. 즉, **스트림이란, 시간순서에 의해 전달되어진 값들의 collection** 정도로 이해해 보자.
  - 각각의 스트림은 새로 만들어(branch)져서 새로운 스트림이 될 수도 있고, 여러개의 스트림이 합쳐(merge) 질수 도 있다.
  - 스트림은 map, filter과 같은 함수형 메소드를 이용하여, **immutable하게 처리**할 수 있다.
  - 스트림을 listening 함으로써 데이터의 결과값을 얻는다. 이를 **subscribe**라고 표현한다.

  

- ### MVC 패턴이란 무엇인가?

  #### MVC (Model - View - Controller)

  ![img](https://t1.daumcdn.net/cfile/tistory/2405DC46577868AF13)

  가장 유명한 패턴으로 Model, View, Controller 3가지 요소로 구성된다.

  - Model: 애플리케이션에서 사용하는 데이터를 관리하는 영역
  - View: 사용자에게 보이는 부분
  - Controller: 사용자의 입력을 받아 모델 데이터를 조회/수정하고 변경 사항을 뷰에 반영

  MVC 패턴은 Model과 View 사이에 강한 결합(Coupling)이 있어 서로 의존적이라는 단점이 있다. 이들의 의존성을 줄이기 위해서 나온 패턴이 MVP이다.

  #### MVP(Model-View-Presenter)

  MVP는 Controller 대신 Presenter가 존재한다.

  * Presenter: 뷰에서 정보를 요청하면 모델 데이터를 조회/수정해서 뷰로 전달

  Model과 View 사이에 Presenter를 넣어 Model-View 사이의 의존성이 없어졌으나 Presenter와 View 가 강한 의존성을 갖게 된다. 이를 보완한 패턴이 MVVM이다.

  

  

- ### Git 과 GitHub 에 대해서

  https://www.slideshare.net/ky200223/git-89251791

  Git은 VCS(Version Control System)이다. Linux 프로젝트 중 버전관리 소프트웨어의 내부 개발이 필요하다고 판단한 리누스 토발즈가 개발했다. 비선형적인 개발을 위해 branch 시스템을 도입했고 원격 저장소와 로컬을 분리함으로써 여러 개발자가 분산 작업을 원활하게 할 수 있게 고안되었다. 또한 모든 commit에 대해 Checksum(Hash)를 만들어 데이터 무결성을 보장한다. (SHA-1)

## 💡 자료구조 [Link](https://github.com/JaeYeopHan/for_beginner/tree/master/DataStructure)

- ### Array vs Linked List

  - #### Array

    가장 기본적인 자료구조인 Array(배열) 자료구조는 논리적 저장 순서와 물리적 저장 순서가 일치하기 때문에 index로 해당 원소에 빠르게 접근할 수 있다. index만 알면 O(1) 시간에 해당 원소로 직접 random access가 가능하다.

    그러나 연속된 데이터 배열에서 원소의 삽입 또는 삭제가 일어날 경우 뒤에 있는 모든 원소들을 이동시켜야하는 비용이 따른다. 이 때 O(n)의 시간 복잡도가 요구된다.

  - #### Linked List

    Linked List(연결 리스트) 자료구조는 논리적인 저장 순서와 물리적인 저장 순서가 일치하지 않는다. 각 원소들은 자신의 값과 자기 바로 다음의 원소만을 기억하고 있다. 따라서 삭제와 삽입이 간단하지만 원하는 특정 위치로 가기 위해서는 처음부터 하나씩 거쳐야 하는 access 시간이 걸린다.

    

- ### Stack and Queue

  - #### Stack

    선형 자료구조의 일종으로 LIFO(Last In First Out), 즉 나중에 들어간 원소가 먼저 나온다(pop). Stack의 꼭대기에 있는 원소를 top이라고 하고 원소를 넣는 것을 push, 빼는 것을 pop이라고 한다.

  - #### Queue

    선형 자료구조의 일종으로 FILO(First In Last Out), 즉 먼저 들어가면 먼저 나오는 구조이다. 우리가 계산을 위해서 줄을 서는 것과 같다. Queue는 스케줄링을 위해서도 쓰인다.

    

- ### Tree

  트리는 스택, 큐와 다르게 선형 구조가 아닌 비선형 자료구조이다. 트리는 계층적 관계를 표현한다.

  - Node (노드) : 트리를 구성하고 있는 각각의 요소를 의미한다.
  - Edge (간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다.
  - Root Node (루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미한다.
  - Terminal Node ( = leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미한다.
  - Internal Node (내부노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.

  

  #### Binary Tree

  루트 노드를 중심으로 2개의 Sub 트리로 나뉘어진다. 이진트리의 모든 Sub트리는 이진트리여야 한다.

  - Perfect Binary Tree (포화 이진 트리)

    모든 level이 꽉 찬 이진 트리

  - Complete Binary Tree (완전 이진 트리)

    왼쪽 -> 오른쪽 순서로 차곡차곡 채워진 이진 트리

  - Full Binary Tree (정 이진 트리)

    모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 이진 트리

  #### BST (Binary Search Tree)

  이진 트리의 일종으로 효율적인 탐색을 위하여 데이터를 저장하는 규칙이 있다.

  1. 이진 탐색 트리의 노드에 저장된 키는 유일(unique)하다.
  2. 루트 노드의 키가 왼쪽 sub트리를 구성하는 모든 노드의 키보다 크다.
  3. 루트 노드의 키가 오른쪽 sub트리를 구성하는 모든 노드의 키보다 작다.
  4. 왼쪽과 오른쪽 sub트리도 이진 탐색 트리이다.

  이진 탐색 트리의 탐색 연산은 O(log n)의 시간 복잡도를 갖는다. 한 번 탐색할 때마다 탐색해야할 양이 1/2씩 줄기 때문이다.

  

  그런데 이진 탐색 트리가 편향이진트리가 될 경우 검색 시간의 장점을 잃어버린다.

  ![img](https://t1.daumcdn.net/cfile/tistory/99AA8E3B5B33A78109)

  균형을 잡기 위해 트리 구조를 재조정하는 Rebalancing을 구현한 트리 중 하나가 Red-Black Tree이다.

  

  

  ### Binary Heap

  자료구조의 일종으로 Tree 중에서도 배열에 기반한 Complete Binary Tree(완전 이진 트리)이다.

  Max Heap이란 각 노드의 값이 해당 children의 값보다 크거나 같은 완전 이진 트리를 말한다. (Min Heap은 각 노드의 값이 해당 children의 값보다 같거나 작은 완전 이진 트리를 말한다.)

  

- ### Red-Black Tree

  RBT는 BST를 기반으로하는 트리 형식의 자료구조로 RBT에 데이터를 저장하면 검색, 삽입, 삭제에 O(log n)의 시간 복잡도가 소요된다. 

  - 정의
  - 특징
  - 삽입
  - 삭제

  

- ### Hash Table

  hash는 내부적으로 배열을 사용해 데이터를 저장하므로 빠른 검색 속도를 갖는다. 특정한 값을 검색하는 데 데이터 고유의 index로 접근하므로 평균 시간 O(1)의 시간 복잡도를 갖는다. 문제는 index로 저장되는 key 값이 불규칙한 것인데 알고리즘(hash function)을 이용하여 저장할 데이터와 연관된 고유 숫자를 만든 후 이를 index로 사용한다.

  #### Hash Function

  #### Resolve Collision

  - ##### Open Addressing

    해시 충돌 발생 시 다른 해시 버킷에 해당 자료를 삽입하는 방식 -> 계속 비어있는 버킷을 찾아다님

  - ##### Separate Chaining

    Linked List를 사용해서 충돌 발생 시 해당 버킷의 list에 추가

    Tree를 사용

  - Resize

- ### Graph

  Vertex와 Edge의 집합. 트리는 사이클이 허용되지 않는 그래프로 그래프에 포함되는 개념이다.

  #### Graph 용어 정리

  Undirected 그래프와 Directed 그래프. 간선에 방향이 있는지 없는지에 따라 구분된다.

  Undirected 그래프에서 각 Vertex에 연결된 Edge의 수를 Degree라고 한다.

  #### Graph 구현

  #### Graph 탐색

  그래프는 정점의 구성 뿐만 아니라 간선의 연결에도 규칙이 존재하지 않기 때문에 탐색이 복잡하다. 따라서 그래프의 모든 정점을 탐색하기 위한 방법은 다음의 두 가지 알고리즘을 기반으로 한다.

  ##### 깊이 우선 탐색 (Depth First Search: DFS)

  그래프 상에 존재하는 임의의 **한 정점으로부터 연결되어 있는 한 정점으로만** 나아간다라는 방법을 우선으로 탐색한다. 일단 연결된 정점으로 탐색하는 것이다. 연결할 수 있는 정점이 있을 때까지 계속 연결하다가 더이상 연결되지 않은 정점이 없으면 바로 그 전 단계의 정점으로 돌아가서 연결할 수 있는 정점이 있는지 살펴봐야 할 것이다. 갔던 길을 되돌아 오는 상황이 존재하는 미로찾기처럼 구성하면 되는 것이다. 어떤 자료구조를 사용해야할까? 바로 Stack 이다. **Time Complexity : O(V+E) … vertex 개수 + edge 개수**

  ##### 너비 우선 탐색 (Breadth First Search: BFS)

  그래프 상에 존재하는 임의의 **한 정점으로부터 연결되어 있는 모든 정점으로** 나아간다. Tree 에서의 Level Order Traversal 형식으로 진행되는 것이다. BFS 에서는 자료구조로 Queue 를 사용한다. 연락을 취할 정점의 순서를 기록하기 위한 것이다. 우선, 탐색을 시작하는 정점을 Queue 에 넣는다.(enqueue) 그리고 dequeue 를 하면서 dequeue 하는 정점과 간선으로 연결되어 있는 정점들을 enqueue 한다. 즉 vertex 들을 방문한 순서대로 queue 에 저장하는 방법을 사용하는 것이다. **Time Complexity : O(V+E) … vertex 개수 + edge 개수** ***! BFS 로 구한 경로는 최단 경로이다.***

  #### Minimum Spanning Tree

  그래프 G의 spanning tree 중 weight의 합이 최소인 spanning tree를 말한다. (spanning tree : 그래프의 모든 vertex가 cycle 없이 연결된 형태)

  - ##### Kruskal algorithm

    초기화 작업으로 **edge 없이** vertex 들만으로 그래프를 구성. weight 가 제일 작은 edge 부터 검토

  - ##### Prim algorithm

    초기화 과정에서 한 개의 vertex 로 이루어진 초기 그래프 A 를 구성. 그래프 A 내부에 있는 vertex 로부터 외부에 있는 vertex 사이의 edge 를 연결하는데 그 중 가장 작은 weight 의 edge 를 통해 연결되는 vertex 를 추가.



## 💡 네트워크 [Link](https://github.com/JaeYeopHan/Beginner_for_interview/tree/master/Network)

- ### JSON(JavaScript Object Notation)

  클라이언트와 서버 간에는 데이터 교환이 필요하다. [JSON(JavaScript Object Notation)](http://www.json.org/json-ko.html)은 클라이언트와 서버 간 데이터 교환을 위한 규칙 즉 데이터 포맷을 말한다.

  JSON은 일반 텍스트 포맷보다 효과적인 데이터 구조화가 가능하며 [XML](https://ko.wikipedia.org/wiki/XML) 포맷보다 가볍고 사용하기 간편하며 가독성도 좋다.

  자바스크립트의 객체 리터럴과 매우 흡사하다. 하지만 **JSON은 순수한 텍스트로 구성된 규칙이 있는 데이터 구조이다.**

  브라우저는 XMLHttpRequest 객체를 이용해 Ajax 요청을 생성하고 전송한다.

- ### GET, POST 방식의 차이점

  #### GET

  GET 방식은 요청하는 데이터가 HTTP Request Message의 Header 부분의 URL에 담겨서 전송된다. URL의 일부분인 쿼리문자열(query string)로 데이터를 서버로 전송한다.

  **요청 메소드가 GET인 경우, send 메소드의 인수는 무시되고 request body은 null로 설정된다.**

  #### POST

  POST 메소드의 경우, 데이터(페이로드)를 Request Body에 담아 전송한다.

  

  GET 방식의 요청은 브라우저에서 Caching 할 수 있다. 때문에 POST 방식으로 요청해야 할 것을 보내는 데이터의 크기가 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청한다면 기존에 caching 되었던 데이터가 응답될 가능성이 존재한다. HTTP 요청 시에는 목적에 맞는 메소드를 사용해야 한다.

  

- ### TCP 3-way-handshake

  ![img](https://t1.daumcdn.net/cfile/tistory/2352F94A58D7287932)

  네트워크 연결 성립(Connection Establishment) 시

  1. 클라이언트 -> 서버로 접속을 요청하는 SYN(a) 패킷 보냄
  2. 서버는 클라이언트의 요청인 SYN(a)를 받고 요청을 수락한다는 ACK(a+1)와 SYN(B)를 발송
  3. 클라이언트는 서버의 수락 응답인 ACK(a+1)와 SYN(b) 패킷을 받고 ACK(b+1)을 서버로 보내면 연결이 성립(establish)된다.

  

- ### TCP 와 UDP 의 차이점

  #### UDP (User Datagram Protocol)

  UDP는 Connectless Protocol로 흐름 제어, 오류 제어 또는 손상된 segment의 수신에 대한 재전송을 하지 않는다. UDP는 오직 포트를 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다. 보낸 패킷이 목적지에 도착할거라는 보장이 없다.

  DNS가 UDP를 사용한다. 호스트 이름의 IP 주소를 찾는 프로그램이 DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보내면 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답한다. 

  #### TCP (Transmission Control Protocol)

  TCP는 Connection-oriented Protocol로 신뢰성 있는 full-duplex byte stream을 전송한다.

  TCP에서 연결 설정은 3-Way Handshake를 통해 행해진다.

  모든 TCP 연결은 full-duplex, point-to-point 방식이다. full-duplex란 전송이 양방향으로 동시에 일어날 수 있음을 의미하며 point-to-point란 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미한다. 즉, TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.

- ### HTTP 와 HTTPS 의 차이점

  #### HTTP의 문제점

  - **HTTP는 Plaintext 통신**이기 때문에 도청이 가능함
  - 통신 상대를 확인하지 않으므로 위장이 가능
  - 완전성을 증명할 수 없기 때문에 변조 가능

  #### 1. TCP/IP는 도청 가능한 네트워크이다

  TCP/IP 구조의 통신은 통신 경로에서 패킷을 수집하는 것만으로도 도청할 수 있다. HTTP는 암호화를 하지 않기 때문에 평문 메시지를 탈취당할 수 있다.

  ##### 해결 방법

  1. 통신 자체를 암호화 : SSL(Secure Socket Layer) / TLS(Transport Layer Security)라는 다른 프로토콜을 조합해 HTTP 통신 내용을 암호화한다. SSL을 조합한 HTTP를 HTTPS라고 한다.
  2. 콘텐츠를 암호화 : HTTP를 사용해서 운반하는 메시지에 포함되는 콘텐츠만 암호화. 받은 쪽에서 decoding 처리 필요

  #### 2. 통신 상대를 확인하지 않아 위장이 가능

  HTTP에 의한 통신에는 상대가 누구인지 확인하는 처리가 없으므로 누구나 리퀘스트를 보낼 수 있다. -> Dos 공격을 방지할 수 없다. 또한 클라이언트와 서버가 둘 다 의도한 곳으로 리스폰스를 보냈는지 확인할 수 없다.

  ##### 해결 방법

  SSL은 상대를 확인하는 수단으로 인증서(certificate: 신뢰할 수 있는 제 3자기관에 의해 발행됨)를 사용하여 해당 클라이언트와 서버가 실재한다는 것을 확인할 수 있다.

  #### 3. 완전성을 증명할 수 없기 때문에 변조가 가능

  완전성 = 정보의 정확성으로 상대방이 보낸 메시지가 중간에 변조되지 않았는지 확신할 수 없다. (Man-in-the-Middle 공격 등)

  ##### 해결 방법

  MD5, SHA-1 등의 해시 값을 확인하는 방법과 파일의 Digital Signature를 확인하는 방법이 필요하지만 확실하게 확인하는 방법은 아니다. 확실히 방지하기 위해서는 SSL을 사용한 HTTPS를 사용해야 한다.

  

  #### HTTPS

  HTTPS는 SSL의 껍질을 덮어 쓴 HTTP라고 할 수 있다. HTTPS는 새로운 애플리케이션 계층의 프로토콜이 아니라 통신하는 소켓 부분을 SSL/TLS 프로토콜로 대체하는 것이다.

  

- ### 웹 통신의 큰 흐름

  Chrome을 실행시켜 주소창에 특정 URL 값을 입력했을 때 일어나는 일

  #### in 브라우저

  1. 웹 브라우저가 URL을 해석한다.
  2. 조사된 의미에 따라 HTTP Request 메시지를 생성한다.
  3. 만들어진 메시지를 웹 서버로 전송한다.

  이 때 만들어진 메시지 전송은 브라우저가 직접 하는 것이 아니라 OS가 전달한다. 단, OS가 메시지를 보내기 위해서는 URL 도메인 명이 아니라 IP 주소가 필요한데 이 때 DNS 서버를 조회해야 한다.

  #### DNS(Domain Name Server) 조회

  1. DNS에 요청을 보내기 전에 먼저 Browser에 해당 Domain이 cache돼 있는지 확인한다. (Chrome의 경우 chrome://net-internals/#dns 에서 확인 가능)

  2. 없을 경우 로컬에 저장돼 있는 hosts파일에서 참조할 수 있는 Domain이 있는지 확인한다.

  3. 1, 2가 모두 실패 했을 경우 Network stack에 구성돼 있는 DNS로 요청을 보낸다. (DNS는 일반적으로 Local router, ISP의 캐싱 DNS)

  #### ARP(Address Resolution Protocol)로 대상의 IP와 Mac address를 알아냄

  ARP broadcast를 보내려면 Network stack library가 조회 할 대상 IP 주소와 ARP broadcast에 사용할 인터페이스의 MAC address를 알아야 한다.

   ARP cache는 대상 IP에 대한 ARP 항목을 확인해서 cache가 있을경우 MAC주소를 반환한다.

   ARP cache가 없는 경우 : 

  1. 대상 IP address가 local subnet에 있는지 확인하기 위해 routing table 조회

  2. 있는경우 subnet과 연관된 interface 사용, 없는 경우 기본 gateway의 subnet과 연관된 interface 사용

  3. Network library는 Link Layer(OSI Model Layer 2)에 ARP 요청을 보냄

  4. 응답에서 target의 MAC address와 IP address로 DNS 프로세스 다시 시작

  5. DNS에 53번 포트를 열어서 UDP 요청을 보낸다. (응답 데이터가 큰경우 TCP가 대신 사용)

  6. 로컬 / ISP DNS에 없는 경우 SOA(Service-oriented architecture)에 도달 할 때까지 재귀요청을 보내서 응답을 받는다.

  #### 대상과 TCP 통신을 통해 Socket을 연다

  이 때 TCP Connection Establishment를 위해 3-Way Handshaking. HTTPS를 이용할 경우 TLS Handshake가 추가됨

  #### in 프로토콜 스택, LAN 어댑터

  1. 프로토콜 스택(OS에 내장된 네트워크 제어용 소프트웨어)이 브라우저로부터 메시지를 받는다.
  2. 받은 메시지를 패킷 속에 저장하고 Sender 주소 등의 제어 정보를 덧붙인다.
  3. 패킷을 LAN 어댑터에 넘긴다.
  4. LAN 어댑터는 패킷을 전기 신호로 변환하고 신호를 LAN 케이블에 송출한다.

  프로토콜 스택은 통신 중 오류가 발생했을 때 제어 정보를 사용하여 고쳐 보내거나 각종 상황을 조절한다.


  #### in 허브, 스위치, 라우터

  1. LAN 어댑터가 송신한 패킷은 스위칭 허브를 경유하여 인터넷 접속용 라우터에 도착한다.
  2. 라우터는 패킷을 프로바이더(통신사)에 전달한다.
  3. 인터넷에 접속한다.

  #### in 방화벽, 캐시 서버

  1. 액세스 회선으로 통신사용 라우터로 운반되어 목적지로 도착한 패킷은 웹 서버 측의 LAN에 도착한다.
  2. 이 때 방화벽이 도착한 패킷을 검사하는데 웹 서버까지 가지 않아도 되는 패킷은 캐시 서버에 저장된다.

  #### in 웹 서버

  1. 패킷이 물리적인 웹 서버에 도착하면 웹 서버의 프로토콜 스택이 패킷을 추출해 메시지를 복원하고 웹 서버 애플리케이션에 넘긴다.
  2. 메시지를 받은 웹 서버 애플리케이션은 요청 메시지에 따른 데이터를 응답 메시지에 넣어 클라이언트로 응답한다.
  3. 왔던 방식을 거꾸로 거쳐 응답 메시지가 클라이언트로 전달된다.



## 💡 운영체제 [Link](https://github.com/JaeYeopHan/Beginner_for_interview/tree/master/OS)

- ### 프로세스와 스레드의 차이

  #### 프로세스 (Process)

  프로세스란 실행 중인 프로그램을 말한다. 프로세스는 메모리에 mapping되는 주소 공간, 코드, 데이터, 실행 스택, 스택 포인터(SP), 힙, 프로그램 카운터(PC) 등으로 구성되는 실행에 대한 OS의 추상화이다.

  ##### Process Table

  PCB(Process Control Block)을 포함한 테이블로 PID를 index로 해서 접근한다. PCB는 프로세스에 대한 모든 데이터를 포함하거나 가리키는 커다란 자료 구조이다. OS는 프로세스의 생성과 동시에 고유한 PCB를 생성해 프로세스에 대한 모든 정보를 PCB에 저장한다. 이는 프로세스가 CPU를 할당받아 작업을 처리하다가 Interrupt 또는 Scheduling에 의해 CPU를 반환하는 Process Context Switch가 일어날 때 모든 레지스터를 PCB에 저장하고 불러와야하기 때문이다.

  PCB에 저장되는 정보는 아래와 같다.

  - 프로세스 식별자(Process ID, PID) : 프로세스 식별번호
  - 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장
  - 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
  - CPU 레지스터
  - CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
  - 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
  - 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
  - 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등

  

  #### 스레드 (Thread)

  프로세스를 병렬적으로 사용하는 데에는 PCB의 할당, PCB 복사, OS의 Preccess 스케줄링 등의 문제가 있다. 이 때 프로세스를 여러 스레드로 분리하자는 개념이 도입되어 프로세스는 리소스 그룹과 실행 단위인 스레드로 나뉘게 된다. 

  즉, 스레드는 프로세스의 실행 단위이다. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 **프로세스 내의 주소 공간이나 자원을 공유**할 수 있다. 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 **스택**으로 구성된다. 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 그리고 열린 파일이나 신호와 같은 운영체제 자원들을 공유한다. 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 멀티스레딩이라고 한다. 이 경우 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터 값을 갖고 있다.

  


  #### 멀티 스레드의 장 단점

  스레드는 프로세스보다 가볍고 스레드 간 정보 교환이 빠르다. 특히 프로세스 내의 한 스레드가 block되어도 전체 프로세스가 영향을 받지 않는다. 스레드의 context switch 는 프로세스 context switch 와는 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.

  그러나 프로세스 내의 스레드들이 하나의 프로세스 자원에 접근하는 일에서 문제가 발생한다. 서로 다른 스레드가 자원에 접근해 변경할 때 다른 스레드가 그 자원을 사용하고 있다면 예기치 못한 문제가 발생할 수 있다. 따라서 멀티 스레딩 환경에서는 Synchronization이 필요하다.

  ### 멀티 스레드 vs 멀티 프로세스

  멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 Synchronization 문제를 안고 있다. 반면 멀티 프로세스 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재한다.

- ### 스케줄러의 종류

  프로세스를 스케줄링하기 위한 Queue는 3가지가 있다.

  - Job Queue: 현재 시스템 내에 있는 모든 프로세스의 집합
  - Ready Queue: 현재 메모리에 올라와 있으면서 CPU를 할당받아 실행되기를 기다리는 프로세스의 집합
  - Device Queue: Device I/O 작업을 대기하고 있는 프로세스의 집합

  따라서 각각의 Queue에 프로세스를 이동시키는 스케줄러도 3종류가 있다.

  - Job Scheduler(장기 스케줄러): 한정된 메모리에 많은 프로세스가 한거번에 올라올 경우 대용량 메모리(디스크)에 임시로 저장된다. 이 pool에 저장된 프로세스 중 메모리를 할당하여 Ready Queue로 보낼 프로세스를 결정한다.

    - 메모리와 디스크 사이의 스케줄링 담당
    - 프로세스에 memory 및 리소스 할당
    - 프로세스의 상태를 new -> ready로 

  - CPU Scheduler(단기 스케줄러)

    - CPU와 메모리 사이의 스케줄링을 담당
    - Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정
    - 프로세스에 CPU를 할당
    - 프로세스의 상태를 ready -> runnung -> waitng -> ready로

  - Swapper(중기 스케줄러)

    - 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아낸다. 이를 swapping이라고 한다.
    - 프로세스에게서 memory를 deallocate 한다.
    - 프로세스의 상태를 ready -> suspended로

    Process State - suspanded(stopped): 외부적인 이유로 프로세스의 수행이 정지된 상태로 메모리에서 내려간 것을 의미. 프로세스 전부 디스크로 swap out된다. blocked 상태는 다른 I/O 작업이 끝나면 ready로 돌아가지만 suspended는 외부적인 이유로 suspending 되었으므로 스스로 돌아갈 수 없다.

    

- ### CPU 스케줄러

  Ready Queue에 있는 프로세스를 스케줄링한다.

  #### FCFS(First Come First Served)

  먼저 오면 먼저 처리. Non-Preemptive 스케줄링 (일단 CPU 잡으면 끝날 때까지 반환하지 않음)

  문제점: 소요시간이 긴 프로세스가 한 번 잡아버리면 뒤에 빨리 끝나는 애들이 손해

  #### SJF(Shortest - Job - First)

  다른 프로세스가 먼저 도착했어도 CPU burst time 짧은 프로세스에게 먼저 할당. Non-Preemptive

  문제점: Starvation 문제. 무거운 프로세스는 계속 순위에서 밀려남

  #### SRTN(Shortest Remaining Time Next)

  Shortest job First의 Preemptive 버전. 남은 실행 시간이 가장 적은 프로세스를 선택한다.

  문제점: 사전에 프로세스들의 런타임을 계산해야 한다.

  #### Round-Robin Scheduling

  가장 오래되고 간단하고 공평하고 자주 사용되는 알고리즘이다. 각 프로세스는 quantum이라는 동일한 할당 시간을 받는다. quantum이 너무 길면 FCFS와 다를 게 없고 너무 짧으면 context switch가 많아져 overhead가 발생하므로 적당한 quantum 시간을 설정하는 것이 중요하다.

  #### Priority scheduling

  우선순위가 가장 높은 프로세스에 CPU를 할당한다. 우선순위는 정수로 작은 숫자가 우선이다.

  Preemptive 방식 - 더 높은 우선순위 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU를 선점

  Non-Preemptive 방식 - 더 높은 우선순위의 프로세스가 도착하면 Ready Queue의 head에 넣는다.

  문제점: Starvation - Proirity 낮으면 계속 못 받음

  #### 

- ### 동기와 비동기의 차이

  #### Blocking I/O Model (Synchronous)

  ![img](https://t1.daumcdn.net/cfile/tistory/22123438588F4A7405)

  User Level에서 수행할 수 없는 I/O 작업을 수행해야할 경우 System Call을 통해 Kernel Mode로 전환하여 OS에 작업을 요청해야 한다. 이 때 Context-switching이 일어나고 Kernel Level에서 해당 I/O 작업을 마치고 결과를 반환하면 그 때 block이 풀린다. 이렇게 한 프로세스의 작업이 끝날 때까지 block하고 기다리는 것을 Synchronous Model 또는 Blocking I/O Model이라고 한다.

  #### Non-Blocking I/O Model 

  ![img](https://t1.daumcdn.net/cfile/tistory/221EB538588F4AF01E)

  한정된 CPU 자원을 사용하는 프로세스가 block되어 다른 프로세스들이 CPU를 할당받지 못하는 것은 자원의 낭비이므로 non-blocking 방식이 만들어졌다. non-blocking 모델은 I/O 작업을 하는 동안 유저 프로세스의 작업을 중단시키지 않는다. System call로 Kernel에 I/O 작업을 전달하고 처리 상황에 상관 없이 바로 결과를 반환한다. 이 구현의 문제점은 애플리케이션에서 polling을 하며 I/O 작업이 끝났는지 계속해서 확인을 해야한다는 것이다.

  

  #### Asynchronous I/O Model

  ![img](https://t1.daumcdn.net/cfile/tistory/2519C04F588F4C8003)

  Event-driven Model이라고도 불리며 polling을 통해 계속해서 확인하는 것이 아니라 Kernel에서 I/O 작업이 완료되었을 때 System Interrupt를 발생시켜 알려주면 Handler로 처리한다.

  

- ### 프로세스 Synchronization

  위에서 멀티프로세싱/멀티스레딩 환경에서 shared resource에 접근할 때 다른 프로세스/스레드가 해당 자원에 접근하지 못하도록 Synchronization이 필요하다고 했다.

  #### Race Condition

  둘 혹은 이상의 프로세스들이 하나의 공유 데이터에 접근하고 수정하여 output이 타이밍에 따라 예측할 수 없게 되는 문제.

  #### Critical Section(Critical Regions)

  공유되는 자원에 접근하는 코드 영역

  #### CSP(Critical Section Problem) 해결을 위한 Requirments

  - Mutual Exclusion

    Critical Section에는 최대 1개의 스레드만 들어가있을 수 있다.

  - Bounded Waiting(no starvation)

    Critical Section 진입을 기다리고 있던 스레드는 진입 가능한 상황이 됐을 때 즉각 진입할 수 있어야 한다.

  - Progress

    스레드 T가 critical section에서 나왔는데도 T 때문에 다른 스레드가 critical section에 들어가지 못하면 안 된다.

  #### CSP 해결책

  ##### Lock

  global 변수인 lock 변수를 사용한다. 어떤 프로세스가 critical section에 진입해야할 때 lock이 0이면 들어갈 수 있고 critical section에 진입하자마자 lock을 1로 변경해 다른 프로세스의 진입을 막는다.

  - lock을 걸기 전에 interrupt가 걸려버리면 둘 다 c/s에 진입하는 mutex 위반 이 생길 수 있고 lock을 풀기 전에 interrupt가 걸려 다른 프로세스가 진입했는데 lock이 걸려있어 진입을 못 하는 progress 위반이 생길 수 있다. 이를 방지하기 위해 atomic한 TSL(Test and Set Lock)을 사용한다. 이는 중간에 interrupt를 받지 않고 하드웨어가 TSL instruction을 수행할 것을 보장한다.

  그러나 lock은 busy wating을 해야해서 효율성이 너무 떨어진다.

  ##### Semaphores

  down, up이라는 2개의 연산을 통해 atomic하게 조작되는 변수.

  down(&semaphore): semaphore -1 을 수행하고 semaphore가 0보다 같거나 작으면 wait(block)시킨다. (atomic) wait에서 깨워지면 다시 down 연산을 수행한다.

  up(&semaphore): semaphore +1 을 수행하고 다른 스레드가 critical section에 진입하도록 허용한다. (down에서 기다리고 있는 스레드 하나를 깨운다.)

  ##### Monitors

  - 고급 언어의 설계 구조물로서, 개발자의 코드를 상호배제 하게끔 만든 추상화된 데이터 형태이다.
  - 공유자원에 접근하기 위한 키 획득과 자원 사용 후 해제를 모두 처리한다. (세마포어는 직접 키 해제와 공유자원 접근 처리가 필요하다. )

  

- ### 메모리 관리 전략

  물리적 메모리를 프로세스에 직접 공개하는 것은 위험하다.

  1. 사용자 프로그램이 메모리의 모든 공간에 접근할 수 있으면 OS를 지워버릴 수도 있다.
  2. 한 번에 여러 프로그램을 돌리기 힘들다.

  따라서 메모리에 대한 추상화가 필요해져서 나온 개념이 address space이다. address space란 프로세스가 사용할 수 있는 주소 범위를 말하며 각 process는 다른 process와 구분되는 고유의 address space를 가진다.

  #### Base and Limit Register

  각각의 프로세스가 가지는 address space를 실제의 물리적 메모리 공간에 매핑하는 것을 dynamic relocation이라고 하는데 이 때 base register, limit register라는 특별한 레지스터가 사용된다.

  Base register: 프로그램이 load된 위치의 물리적 메모리 주소값(프로그램은 0이라고 시작하지만 실제로는 base register 값에 위치한다.) 프로그램의 virtual address에 base register를 더하면 실제 물리적 메모리 주소가 나오므로 relocation 문제가 해결된다.

  Limit register: 프로그램의 길이

  Relocation의 단점은 매번 메모리를 접근할 때마다 limit reg를 안 넘는지 검사하고 relocation 연산(base reg 더하기)을 해야해서 오래 걸린다는 것이다.

  #### Swapping

  컴퓨터의 물리적 메모리가 모든 프로세스를 돌리기에 크기가 부족할 때 memory overhead가 일어난다고 한다. memory overhead를 해결하기 위해서 가장 간단한 방법을 프로세스 전체를 디스크로 swap out했다가 여유가 생기면 다시 swap in 하는 swapping 방법이다. 다른 전략으로는 프로그램의 일부만을 메모리에 올려서 실행하는 virtual memory 전략이 있다.

  Swapping을 하며 프로세스가 메모리에 적재되었다가 제거되는 일이 반복되면 메모리 중간에 남는 공간이 생긴다. 이 문제를 Fragmentation이라고 한다. Fragmentation은 memory compaction으로 해결할 수 있는데 CPU 시간을 많이 잡아먹어 효율적이지 않다.

  #### 

- ### 가상 메모리

  virtual memory가 도입되기 전에는 메모리의 크기가 프로그램의 크기보다 반드시 커야 프로그램을 메모리에 올려서 실행시킬 수 있었다. 그러나 프로그램이 발전하면서 메모리의 용량을 초과하게 되면서 불필요한 프로그램 전체가 메모리에 올라가는 것을 방지하고자 virtual memory가 도입되었다.

  virtual memory는 프로세스를 disk와 memory에 나눠서 저장한다. 각 프로그램이 가진 address space의 일부(page)만 memory에 적재하는 것이다. 각 page들은 연속된 주소를 가지고 있고 물리적 메모리에 매핑된다.

  #### Paging

  virtual(logical) 주소를 physical주소로 변환하여 relocation하려면 프로그램 전체가 메모리에 올라와야 하는 Swapping 방식의 단점을 보완하기 위해 Paging이 도입되었다.

  MMU에 의해 만들어진 virtual address들은 virtual address space를 형성한다. 가상 메모리를 사용하면 virtual address에 접근 시 MMU를 통해 physical address로 접근된다.

  가상 메모리 공간은 page로 이루어져있고 각 페이지에 매핑되는 물리적 메모리 공간을 page frame이라고 한다.

  #### Page Tables

  OS가 관리하는 page tagle은 virtual page를 page frame과 매핑하기 위해 존재하며 page 당 하나의 PTE(Pate Table Entry)를 갖는다.

  Paging의 2가지 개선해야할 점으로

  1. virtual address -> physical address로의 매핑이 빨라야한다. (page table을 거쳐 page fault시 memory까지 갔다옴)
  2. virtual address space가 커지면 page table이 메모리에서 많은 영역을 차지한다.

  Paging을 빠르게 하기 위해서 TLB(Translation Lookaside Buffer)가 도입됐다. MMU 안에 작은 테이블로 존재하는 TLB는 virtual memory 접근 시

  - TLB hit - page table까지 안 가고 바로 page frame 접근
  - TLB miss - page table 가서 제일 안 쓰이는 거랑(LRU) page 교체 -> page table에도 없으면 Page Fault -> OS

  Context Switch가 일어날 경우 Page Table도 교체되므로 TLB도 비워지고 채워지는 동안 계속 TLB miss가 발생한다.

  #### Page 교체 알고리즘

  Page fault가 발생하면 OS는 요구된 page를 적재하기 위해서 메모리에서 제거할 page를 선택해야 한다. 이런 방식을 Demanding Paging이라고 하는데 Page fault가 일어나면 그때 비로소 frame을 할당하는 방식을 말한다.

  ##### FIFO 페이지 교체

  가장 간단한 페이지 교체 알고리즘으로 FIFO(first-in first-out)의 흐름을 가진다. 즉, 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다는 것이다.

  - 장점
    - 이해하기도 쉽고, 프로그램하기도 쉽다.
  - 단점
    - 오래된 페이지가 항상 불필요하지 않은 정보를 포함하지 않을 수 있다(초기 변수 등)
    - 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있다.
    - `Belady의 모순`: 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.

  ##### 최적 페이지 교체(Optimal Page Replacement)

  `Belady의 모순`을 확인한 이후 최적 교체 알고리즘에 대한 탐구가 진행되었고, 모든 알고리즘보다 낮은 페이지 부재율을 보이며 `Belady의 모순`이 발생하지 않는다. 이 알고리즘의 핵심은 `앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체`하는 것이다. 주로 비교 연구 목적을 위해 사용한다.

  - 장점
    - 알고리즘 중 가장 낮은 페이지 부재율을 보장한다.
  - 단점
    - 구현의 어려움이 있다. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문이다.

  ##### LRU 페이지 교체(LRU Page Replacement)

  `LRU: Least-Recently-Used`
  최적 알고리즘의 근사 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.

  - 특징
    - 대체적으로 `FIFO 알고리즘`보다 우수하고, `OPT알고리즘`보다는 그렇지 못한 모습을 보인다.

  ##### LFU 페이지 교체(LFU Page Replacement)

  `LFU: Least Frequently Used`
  참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘이다.

  - 특징
    - 어떤 프로세스가 특정 페이지를 집중적으로 사용하다, 다른 기능을 사용하게되면 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생할 수 있다
    - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.

  ##### MFU 페이지 교체(MFU Page Replacement)

  `MFU: Most Frequently Used`
  참조 회수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반한다.

  - 특징
    - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.

   

  #### Segmentation

  Paging처럼 virtual memory와 physical memory를 같은 크기의 블록이 아닌 서로 다른 크기의 논리적 단위인 segment로 분할하는 것.... ㅁㄹ Segment도 paging을 해서 쓴다고 배웠다.

  

- ### 캐시의 지역성

  - Locality
  - Caching line



## 💡 데이터베이스 [Link](https://github.com/JaeYeopHan/Beginner_for_interview/tree/master/Database)

- ### 데이터베이스

  #### 데이터베이스 관리 시스템을 사용하는 이유

  데이터베이스 이전에는 파일 시스템을 이용해 데이터를 관리했는데 이는 데이터 종속성과 중복성, 무결성 문제를 야기했다.

  #### DBMS의 특징

  1. 데이터의 독립성(Data Independency)

     - 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.
     - 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양항 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.

  2. 데이터의 무결성(Data Integrity)

     여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.

  3. 데이터의 보안성(Data Security)

     인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.

  4. 데이터의 일관성(Data Consistency)

     연관된 정보를 논리적은 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.

  5. 데이터 중복(Data Redunancy)

     최소화 데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

- ### DBMS의 정의

  DBMS(Database Management Sysyem): 응용 프로그램과 데이터 사이의 중재자로서 모든 응용프로그램들이 데이터베이스를 공용할 수 있게 관리해주는 소프트웨어 시트템

  #### DBMS의 필수 기능 3가지

  1. 정의(definition): 하나의 물리적 구조의 데이터베이스로 여러 사용자의 요구를 지원할 수 있도록 적절한 데이터베이스 구조를 정의하는 기능
  2. 조작(manipulation): 사용자의 요구에 따라 체계적으로 데이터베이스 접근, 조작하는 인터페이스 수단 제공 -> SQL 언어
  3. 제어(control): 공용 목적으로 관리되는 데이터베이스의 정확성과 안정성 유지

- ### Index

  - Index 란 무엇인가
  - Index 의 자료구조
  - Primary index vs Secondary index
  - Composite index
  - Index 의 성능과 고려해야할 사항

- ### 정규화에 대해서

  - 정규화 탄생 배경
  - 정규화란 무엇인가
  - 정규화의 종류
  - 정규화의 장단점

- ### Transaction

  - 트랜잭션(Transaction)이란 무엇인가?
  - 트랜잭션과 Lock
  - 트랜잭션의 특성
  - 트랜잭션의 상태
  - 트랜잭션을 사용할 때 주의할 점

- ### Statement vs PreparedStatement

- ### NoSQL

  - 정의
  - CAP 이론
    - 일관성
    - 가용성
    - 네트워크 분할 허용성
  - 저장방식에 따른 분류
    - Key-Value Model
    - Document Model
    - Column Model

#### 추가자료

- [DBMS 는 어떻게 트랜잭션을 관리할까?](https://d2.naver.com/helloworld/407507)



## 💡 Design Pattern [Link](https://github.com/JaeYeopHan/Beginner_for_interview/tree/master/DesignPattern)

- Singleton



## 💡 Algorithm (알고리즘) [Link](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Algorithm)

- 손코딩 및 코딩 테스트 대비 => 대부분의 내용이 코드이기 때문에 별도의 [Java Algorithm Training Repository](https://github.com/JaeYeopHan/algorithm_basic_java)에 저장합니다.
- 코딩 테스트를 위한 Tip
- 문제 해결을 위한 전략적 접근
- Sorting Algorithm
- Prime Number Algorithm



[(목차로 돌아가기)](https://github.com/JaeYeopHan/Interview_Question_for_Beginner#technical-interview-guidelines-for-beginners)



# Part 2. Language

## 💎 JavaScript [Link](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/JavaScript)

- JavaScript Event Loop
- Hoisting
- Closure
- this 에 대해서
- Promise

#### 추가 자료

- [JavaScript 기본서 비교](http://asfirstalways.tistory.com/246)
- [ECMAScript6 정리](https://jaeyeophan.github.io/categories/ECMAScript6)
- Interview Algorithm Questions in JavaScript (영어)
  - JavaScript 와 관련된 인터뷰 관련 내용들을 정리해놓은 자료입니다.

# Part 3. 분야별

## 🔶 Front-End [Link](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/FrontEnd)

- 브라우저의 작동 원리
- Document Object Model
  - Event Bubbling and Capturing
  - Event delegation
- CORS
- 크로스 브라우징
- 웹 성능과 관련된 Issues
- 서버 사이드 렌더링 vs 클라이언트 사이드 렌더링
- CSS Methodology
- normalize.css vs reset.css

#### 추가 자료

- [신입 프론트엔드 개발자가 되려면 무엇을 학습해야 하나요?](https://jbee.io/essay/for_junior_frontend_developer/)
- [Front-end Developer Interview Questions (한국어)](https://h5bp.org/Front-end-Developer-Interview-Questions/translations/korean/)
- [Front-end Interview (영어)](http://thatjsdude.com/interview/index.html)
- Front-end Checklist
  - 면접 시 물어보기 가장 좋은 것들이 '기본'에 대한 내용이라고 생각되는데요, 그 '기본'에 대해 체크리스트 형식으로 잘 정리되어 있는 문서를 공유합니다.
- [Front End Interview Handbook (한국어)](https://github.com/yangshun/front-end-interview-handbook/tree/master/Translations/Korean)
- [React 구조에 대한 고민 시리즈](https://jbee.io/react/react-0-intro/)