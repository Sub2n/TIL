# Part 1. 전산 기초

## 💡 개발상식 [Link](https://github.com/JaeYeopHan/Beginner_for_interview/tree/master/Development_common_sense)

- ### 객체 지향 프로그래밍이란 무엇인가?

  객체지향 프로그래밍은 프로그래밍을 명령어 또는 함수의 목록으로 보는 명령형 프로그래밍의 절차지향적 관점에서 벗어나 **프로그램을 여러개의 독립적 객체들의 집합으로 표현**하려는 프로그래밍 패러다임을 말한다.
  

  #### 객체 지향 프로그래밍의 4가지 원칙

  - 추상화 (abstraction) : 다양한 속성 중에서 프로그램에 필요한 속성만을 간추려내어 표현하는 것을 추상화라고 한다. 불필요한 정보는 숨기고 필요한 정보만을 표현함으로써 공토
  - 캡슐화 (encapsulation) : 모든 객체가 자신의 상태(state, private variavles)를 클래스 내부에 private으로 보유함으로써 지켜진다. 내부 상태를 내부 메소드로만 접근할 수 있게 한다.
  - **상속 (inheritance)** : 객체지향 프로그래밍의 핵심 개념으로 부모 객체의 프로퍼티를 자식 개체가 상속받아 그대로 사용할 수 있는 것을 말한다.
  - 다형성 (polymorpism) : 부모 객체가 선언한 interface 메소드를 자식 객체가 재정의(overiding) 함으로써 하나의 interface로 상황에 따라 기능을 달리 하는 것을 말한다.

  ###### Function OverLoading : 이름은 같지만 signature(parameter 수, data type)는 다른 method를 중복으로 선언하는 것

  method 이름은 같아야 한다. Parameter 수는 달라야 하며, 같다면 data type이 달라야 한다.

  ###### Method OverRiding : 부모 클래스의 method 동작 방법을 재정의하여 우선적으로 사용하는 것.

  override 하고자 하는 method가 상위 클래스에 존재해야 한다. Method 이름이 같아야 하며, parameter 개수, data type, return type 등 모든 signature를 동일하게 사용한다. 달라지는 것은 내부 구현 뿐이다.

  부르는 object만 달라질뿐 method 이름을 동일하게 하면 하나의 method로 여러 기능을 실행할 수 있다.

  #### 객체 지향적 설계 원칙

  1. **S**RP(Single Responsibility Principle) : 단일 책임 원칙
     클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
  2. **O**CP(Open-Closed Principle) : 개방-폐쇄 원칙
     확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
  3. **L**SP(Liskov Substitution Principle) : 리스코프 치환 원칙
     상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
  4. **I**SP(Interface Segregation Principle) : 인터페이스 분리 원칙
     “특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.”
  5. **D**IP(Dependency Inversion Principle) : 의존 역전 원칙
     고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

  

- ### RESTFul API 란?

  REST란 REpresentational State Transfer의 약자로 RESTful API란 REST의 기본 원칙에 충실한 서비스 디자인이다.

  #### 1. REST API 중심 규칙

  ##### 1) URI는 정보의 자원을 표현해야 한다.

  리소스명으로 동사보다는 명사를 사용

  URI는 자원을 표현하는 데 중점 두어야 함

  ##### 2) 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)로 표현한다.

  ```
  # bad
  GET /books/delete/1
  
  # good
  DELETE /books/1
  ```

  #### 2. HTTP Method

  주로 5자리 Method를 사용해서 **CRUD** (Create, Read, Update, Delete) 구현

  | Method | Action         | 역할                  |
  | :----- | :------------- | :-------------------- |
  | GET    | index/retireve | 모든/특정 리소스 조회 |
  | POST   | create         | 리소스 생성           |
  | PUT    | update all     | 모든 리소스 갱신      |
  | PATCH  | update         | 리소스 갱신           |
  | DELETE | delete         | 리소스 삭제           |

  #### 3. Configuring the REST API

  ##### REST의 3요소

  | 구성 요소       | 내용                            | 표현 방법                 |
  | :-------------- | :------------------------------ | :------------------------ |
  | Resource        | Resource                        | HTTP URI                  |
  | Verb            | Actions on Resources            | HTTP Method               |
  | Representations | Details of actions on resources | HTTP Message **Pay Load** |

  REST는 Self-descriptiveness(자체 표현 구조)로 구성되어 REST API만으로 Request를 이해할 수 있다.

  

- ### TDD 란 무엇이며 어떠한 장점이 있는가?

  Test-Driven Development(TDD)는 **매우 짧은 개발 사이클의 반복**에 의존하는 소프트웨어 개발 프로세스이다. 개발자는 우선 새로운 요구사항에 대한 자동화된 테스트케이스를 작성하고, 해당 테스트를 통과하는 가장 간단한 코드를 작성한다. 일단 테스트를 통과하면 상황에 맞게 리팩토링하는 과정을 거친다. Test-Driven의 말 뜻 그대로 테스트가 코드 작성을 주도하는 개발 방식이다.

  #### 테스트 추가

  TDD에서는 새로운 기능을 추가하기 전에 테스트를 먼저 작성한다. 테스트 작성을 위해서는 기능의 요구사항과 명세를 분명히 이해하고 있어야한다.

  #### 모든 테스트 수행하고 실패하는 것 찾기

  새로운 기능을 추가하면 잘 작동하던 기능이 제대로 작동하지 않을 수 있으므로 테스트 코드를 작성함으로써 새로운 기능이 제대로 작동함과 동시에 기존 기능이 유지되는지 테스트를 통해 확인한다.

  #### 코드 리팩토링

  

- ### 함수형 프로그래밍이란?

  OOP(Object Oriented Programming : 객체 지향 프로그래밍)와 FP(Functional Programming : 함수형 프로그래밍)의 차이점에 대해서 알아본다.

  프로그래밍 패러다임에는 명령형 프로그래밍과 선언형 프로그래밍이 있다.

  #### 명령형 프로그래밍

  프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 방식. 알고리즘을 명시 O 목표 명시 X

  - 절차지향 프로그래밍: 수행되어야 할 연속적인 계산 과정을 표함하는 방식 (C, C++)
  - **객체지향 프로그래밍: 객체들의 집합으로 프로그램의 상호작용을 표현 (C++, Java, C#)**

  #### 선언형 프로그래밍

  어떤 방법으로 해야하는지(How)를 나타내기보다 무엇(What)을 하는지를 설명하는 방식. 알고리즘 명시 X 목표 명시 O

  - **함수형 프로그래밍: 순수 함수(Pure Function)를 조합하여 소프트웨어를 만드는 방식(Closure, Haskell, Lisp)**

  #### 명령형 vs 선언형 자바스크립트로 비교

  ```react
  // 명령형
  function double (arr) {
    let results = []
    for (let i = 0; i < arr.length; i++){
      results.push(arr[i] * 2)
    }
    return results
  }
  
  function add (arr) {
    let result = 0
    for (let i = 0; i < arr.length; i++){
      result += arr[i]
    }
    return result
  }
  
  $("#btn").click(function() {
    $(this).toggleClass("highlight")
    $(this).text() === 'Add Highlight'
      ? $(this).text('Remove Highlight')
      : $(this).text('Add Highlight')
  })
  
  
  // 선언형
  function double (arr) {
    return arr.map((item) => item * 2)
  }
  
  function add (arr) {
    return arr.reduce((prev, current) => prev + current, 0)
  }
  
  <Btn
    onToggleHighlight={this.handleToggleHighlight}
    highlight={this.state.highlight}>
      {this.state.buttonText}
  </Btn>
  ```

  "명령형 프로그래밍은 어떻게 할 것인가(How)를 표현하고, 선언형 프로그래밍은 무엇을 할 것인가(What) 표현한다."

  |                      | 명령형 프로그래밍        | 함수형 프로그래밍           |
  | -------------------- | ------------------------ | --------------------------- |
  | 프로그램이란?        | 프로그램은 명령의 수행   | 프로그램은 함수의 계산      |
  | 중점적 시각          | 어떻게(how to)에 초첨    | 무엇(what)에 초점           |
  | 이론적 배경          | 튜링 머신                | 람다 계산식                 |
  | 주요 프로그래밍 언어 | C, Java 등 대부분의 언어 | Schema, Haskell, ML, Erlang |

  함수형 프로그래밍에 필요한 개념으로는 1급 객체(First class object), 고차 함수(High-order function), 불변성(Immutablility) 유지, 순수 함수(Pure function) 등이 있다.

  #### 함수형 프로그래밍의 가장 큰 특징 2가지

  - immutable data
  - first class citizen으로서의 function

  #### immutable

  immutable이란 말 그래도 변경 불가능한 것으로, immutable 객체란 원래 자바스크립트의 mutable한 객체와 달리 객체 내부의 내용을 직접 변경하지 않고 새로운 객체를 생성하여 재할당을 통해서만 변경하는 객체를 말한다.

  #### first-citizen

  함수형 프로그래밍 패러다임에서의 함수는 일급 객체로(first class) 간주된다.

  아래와 같은 조건을 만족하는 객체를 **일급 객체**([first-class object](https://ko.wikipedia.org/wiki/일급_객체))라 한다.

  1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
  2. 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.
  3. 함수의 매개 변수에게 전달할 수 있다.
  4. 함수의 결과값으로 반환할 수 있다.

  #### Reactive Programming

  반응형 프로그래밍은 선언형 프로그래밍이라고도 불리며 명령형 프로그래밍의 반댓말이다. 반응형 프로그래밍은 함수형 프로그래밍 패러다임을 활용하는 것을 말한다.

  - Reactive Programing은 기본적으로 **모든 것을 스트림(stream)**으로 본다. 이벤트, ajax call, 등 모든 데이터의 흐름을 시간순서에 의해 전달되어지는 스트림으로 처리한다. 즉, **스트림이란, 시간순서에 의해 전달되어진 값들의 collection** 정도로 이해해 보자.
  - 각각의 스트림은 새로 만들어(branch)져서 새로운 스트림이 될 수도 있고, 여러개의 스트림이 합쳐(merge) 질수 도 있다.
  - 스트림은 map, filter과 같은 함수형 메소드를 이용하여, **immutable하게 처리**할 수 있다.
  - 스트림을 listening 함으로써 데이터의 결과값을 얻는다. 이를 **subscribe**라고 표현한다.

  

- ### MVC 패턴이란 무엇인가?

  #### MVC (Model - View - Controller)

  ![img](https://t1.daumcdn.net/cfile/tistory/2405DC46577868AF13)

  가장 유명한 패턴으로 Model, View, Controller 3가지 요소로 구성된다.

  - Model: 애플리케이션에서 사용하는 데이터를 관리하는 영역
  - View: 사용자에게 보이는 부분
  - Controller: 사용자의 입력을 받아 모델 데이터를 조회/수정하고 변경 사항을 뷰에 반영

  MVC 패턴은 Model과 View 사이에 강한 결합(Coupling)이 있어 서로 의존적이라는 단점이 있다. 이들의 의존성을 줄이기 위해서 나온 패턴이 MVP이다.

  #### MVP(Model-View-Presenter)

  MVP는 Controller 대신 Presenter가 존재한다.

  * Presenter: 뷰에서 정보를 요청하면 모델 데이터를 조회/수정해서 뷰로 전달

  Model과 View 사이에 Presenter를 넣어 Model-View 사이의 의존성이 없어졌으나 Presenter와 View 가 강한 의존성을 갖게 된다. 이를 보완한 패턴이 MVVM이다.

  

  

- ### Git 과 GitHub 에 대해서

  https://www.slideshare.net/ky200223/git-89251791

  Git은 VCS(Version Control System)이다. Linux 프로젝트 중 버전관리 소프트웨어의 내부 개발이 필요하다고 판단한 리누스 토발즈가 개발했다. 비선형적인 개발을 위해 branch 시스템을 도입했고 원격 저장소와 로컬을 분리함으로써 여러 개발자가 분산 작업을 원활하게 할 수 있게 고안되었다. 또한 모든 commit에 대해 Checksum(Hash)를 만들어 데이터 무결성을 보장한다. (SHA-1)

## 💡 자료구조 [Link](https://github.com/JaeYeopHan/for_beginner/tree/master/DataStructure)

- ### Array vs Linked List

  - #### Array

    가장 기본적인 자료구조인 Array(배열) 자료구조는 논리적 저장 순서와 물리적 저장 순서가 일치하기 때문에 index로 해당 원소에 빠르게 접근할 수 있다. index만 알면 O(1) 시간에 해당 원소로 직접 random access가 가능하다.

    그러나 연속된 데이터 배열에서 원소의 삽입 또는 삭제가 일어날 경우 뒤에 있는 모든 원소들을 이동시켜야하는 비용이 따른다. 이 때 O(n)의 시간 복잡도가 요구된다.

  - #### Linked List

    Linked List(연결 리스트) 자료구조는 논리적인 저장 순서와 물리적인 저장 순서가 일치하지 않는다. 각 원소들은 자신의 값과 자기 바로 다음의 원소만을 기억하고 있다. 따라서 삭제와 삽입이 간단하지만 원하는 특정 위치로 가기 위해서는 처음부터 하나씩 거쳐야 하는 access 시간이 걸린다.

    

- ### Stack and Queue

  - #### Stack

    선형 자료구조의 일종으로 LIFO(Last In First Out), 즉 나중에 들어간 원소가 먼저 나온다(pop). Stack의 꼭대기에 있는 원소를 top이라고 하고 원소를 넣는 것을 push, 빼는 것을 pop이라고 한다.

  - #### Queue

    선형 자료구조의 일종으로 FILO(First In Last Out), 즉 먼저 들어가면 먼저 나오는 구조이다. 우리가 계산을 위해서 줄을 서는 것과 같다. Queue는 스케줄링을 위해서도 쓰인다.

    

- ### Tree

  트리는 스택, 큐와 다르게 선형 구조가 아닌 비선형 자료구조이다. 트리는 계층적 관계를 표현한다.

  - Node (노드) : 트리를 구성하고 있는 각각의 요소를 의미한다.
  - Edge (간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다.
  - Root Node (루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미한다.
  - Terminal Node ( = leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미한다.
  - Internal Node (내부노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.

  

  #### Binary Tree

  루트 노드를 중심으로 2개의 Sub 트리로 나뉘어진다. 이진트리의 모든 Sub트리는 이진트리여야 한다.

  - Perfect Binary Tree (포화 이진 트리)

    모든 level이 꽉 찬 이진 트리

  - Complete Binary Tree (완전 이진 트리)

    왼쪽 -> 오른쪽 순서로 차곡차곡 채워진 이진 트리

  - Full Binary Tree (정 이진 트리)

    모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 이진 트리

  #### BST (Binary Search Tree)

  이진 트리의 일종으로 효율적인 탐색을 위하여 데이터를 저장하는 규칙이 있다.

  1. 이진 탐색 트리의 노드에 저장된 키는 유일(unique)하다.
  2. 루트 노드의 키가 왼쪽 sub트리를 구성하는 모든 노드의 키보다 크다.
  3. 루트 노드의 키가 오른쪽 sub트리를 구성하는 모든 노드의 키보다 작다.
  4. 왼쪽과 오른쪽 sub트리도 이진 탐색 트리이다.

  이진 탐색 트리의 탐색 연산은 O(log n)의 시간 복잡도를 갖는다. 한 번 탐색할 때마다 탐색해야할 양이 1/2씩 줄기 때문이다.

  

  그런데 이진 탐색 트리가 편향이진트리가 될 경우 검색 시간의 장점을 잃어버린다.

  ![img](https://t1.daumcdn.net/cfile/tistory/99AA8E3B5B33A78109)

  균형을 잡기 위해 트리 구조를 재조정하는 Rebalancing을 구현한 트리 중 하나가 Red-Black Tree이다.

  

  

  ### Binary Heap

  자료구조의 일종으로 Tree 중에서도 배열에 기반한 Complete Binary Tree(완전 이진 트리)이다.

  Max Heap이란 각 노드의 값이 해당 children의 값보다 크거나 같은 완전 이진 트리를 말한다. (Min Heap은 각 노드의 값이 해당 children의 값보다 같거나 작은 완전 이진 트리를 말한다.)

  

- ### Red-Black Tree

  RBT는 BST를 기반으로하는 트리 형식의 자료구조로 RBT에 데이터를 저장하면 검색, 삽입, 삭제에 O(log n)의 시간 복잡도가 소요된다. 

  - 정의
  - 특징
  - 삽입
  - 삭제

  

- ### Hash Table

  hash는 내부적으로 배열을 사용해 데이터를 저장하므로 빠른 검색 속도를 갖는다. 특정한 값을 검색하는 데 데이터 고유의 index로 접근하므로 평균 시간 O(1)의 시간 복잡도를 갖는다. 문제는 index로 저장되는 key 값이 불규칙한 것인데 알고리즘(hash function)을 이용하여 저장할 데이터와 연관된 고유 숫자를 만든 후 이를 index로 사용한다.

  #### Hash Function

  #### Resolve Collision

  - ##### Open Addressing

    해시 충돌 발생 시 다른 해시 버킷에 해당 자료를 삽입하는 방식 -> 계속 비어있는 버킷을 찾아다님

  - ##### Separate Chaining

    Linked List를 사용해서 충돌 발생 시 해당 버킷의 list에 추가

    Tree를 사용

  - Resize

- ### Graph

  Vertex와 Edge의 집합. 트리는 사이클이 허용되지 않는 그래프로 그래프에 포함되는 개념이다.

  #### Graph 용어 정리

  Undirected 그래프와 Directed 그래프. 간선에 방향이 있는지 없는지에 따라 구분된다.

  Undirected 그래프에서 각 Vertex에 연결된 Edge의 수를 Degree라고 한다.

  #### Graph 구현

  #### Graph 탐색

  그래프는 정점의 구성 뿐만 아니라 간선의 연결에도 규칙이 존재하지 않기 때문에 탐색이 복잡하다. 따라서 그래프의 모든 정점을 탐색하기 위한 방법은 다음의 두 가지 알고리즘을 기반으로 한다.

  ##### 깊이 우선 탐색 (Depth First Search: DFS)

  그래프 상에 존재하는 임의의 **한 정점으로부터 연결되어 있는 한 정점으로만** 나아간다라는 방법을 우선으로 탐색한다. 일단 연결된 정점으로 탐색하는 것이다. 연결할 수 있는 정점이 있을 때까지 계속 연결하다가 더이상 연결되지 않은 정점이 없으면 바로 그 전 단계의 정점으로 돌아가서 연결할 수 있는 정점이 있는지 살펴봐야 할 것이다. 갔던 길을 되돌아 오는 상황이 존재하는 미로찾기처럼 구성하면 되는 것이다. 어떤 자료구조를 사용해야할까? 바로 Stack 이다. **Time Complexity : O(V+E) … vertex 개수 + edge 개수**

  ##### 너비 우선 탐색 (Breadth First Search: BFS)

  그래프 상에 존재하는 임의의 **한 정점으로부터 연결되어 있는 모든 정점으로** 나아간다. Tree 에서의 Level Order Traversal 형식으로 진행되는 것이다. BFS 에서는 자료구조로 Queue 를 사용한다. 연락을 취할 정점의 순서를 기록하기 위한 것이다. 우선, 탐색을 시작하는 정점을 Queue 에 넣는다.(enqueue) 그리고 dequeue 를 하면서 dequeue 하는 정점과 간선으로 연결되어 있는 정점들을 enqueue 한다. 즉 vertex 들을 방문한 순서대로 queue 에 저장하는 방법을 사용하는 것이다. **Time Complexity : O(V+E) … vertex 개수 + edge 개수** ***! BFS 로 구한 경로는 최단 경로이다.***

  #### Minimum Spanning Tree

  그래프 G의 spanning tree 중 weight의 합이 최소인 spanning tree를 말한다. (spanning tree : 그래프의 모든 vertex가 cycle 없이 연결된 형태)

  - ##### Kruskal algorithm

    초기화 작업으로 **edge 없이** vertex 들만으로 그래프를 구성. weight 가 제일 작은 edge 부터 검토

  - ##### Prim algorithm

    초기화 과정에서 한 개의 vertex 로 이루어진 초기 그래프 A 를 구성. 그래프 A 내부에 있는 vertex 로부터 외부에 있는 vertex 사이의 edge 를 연결하는데 그 중 가장 작은 weight 의 edge 를 통해 연결되는 vertex 를 추가.



## 💡 네트워크 [Link](https://github.com/JaeYeopHan/Beginner_for_interview/tree/master/Network)

- ### JSON(JavaScript Object Notation)

  클라이언트와 서버 간에는 데이터 교환이 필요하다. [JSON(JavaScript Object Notation)](http://www.json.org/json-ko.html)은 클라이언트와 서버 간 데이터 교환을 위한 규칙 즉 데이터 포맷을 말한다.

  JSON은 일반 텍스트 포맷보다 효과적인 데이터 구조화가 가능하며 [XML](https://ko.wikipedia.org/wiki/XML) 포맷보다 가볍고 사용하기 간편하며 가독성도 좋다.

  자바스크립트의 객체 리터럴과 매우 흡사하다. 하지만 **JSON은 순수한 텍스트로 구성된 규칙이 있는 데이터 구조이다.**

  브라우저는 XMLHttpRequest 객체를 이용해 Ajax 요청을 생성하고 전송한다.

- ### GET, POST 방식의 차이점

  #### GET

  GET 방식은 요청하는 데이터가 HTTP Request Message의 Header 부분의 URL에 담겨서 전송된다. URL의 일부분인 쿼리문자열(query string)로 데이터를 서버로 전송한다.

  **요청 메소드가 GET인 경우, send 메소드의 인수는 무시되고 request body은 null로 설정된다.**

  #### POST

  POST 메소드의 경우, 데이터(페이로드)를 Request Body에 담아 전송한다.

  

  GET 방식의 요청은 브라우저에서 Caching 할 수 있다. 때문에 POST 방식으로 요청해야 할 것을 보내는 데이터의 크기가 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청한다면 기존에 caching 되었던 데이터가 응답될 가능성이 존재한다. HTTP 요청 시에는 목적에 맞는 메소드를 사용해야 한다.

  

- ### TCP 3-way-handshake

  ![img](https://t1.daumcdn.net/cfile/tistory/2352F94A58D7287932)

  네트워크 연결 성립(Connection Establishment) 시

  1. 클라이언트 -> 서버로 접속을 요청하는 SYN(a) 패킷 보냄
  2. 서버는 클라이언트의 요청인 SYN(a)를 받고 요청을 수락한다는 ACK(a+1)와 SYN(B)를 발송
  3. 클라이언트는 서버의 수락 응답인 ACK(a+1)와 SYN(b) 패킷을 받고 ACK(b+1)을 서버로 보내면 연결이 성립(establish)된다.

  

- ### TCP 와 UDP 의 차이점

  #### UDP (User Datagram Protocol)

  UDP는 Connectless Protocol로 흐름 제어, 오류 제어 또는 손상된 segment의 수신에 대한 재전송을 하지 않는다. UDP는 오직 포트를 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다. 보낸 패킷이 목적지에 도착할거라는 보장이 없다.

  DNS가 UDP를 사용한다. 호스트 이름의 IP 주소를 찾는 프로그램이 DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보내면 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답한다. 

  #### TCP (Transmission Control Protocol)

  TCP는 Connection-oriented Protocol로 신뢰성 있는 full-duplex byte stream을 전송한다.

  TCP에서 연결 설정은 3-Way Handshake를 통해 행해진다.

  모든 TCP 연결은 full-duplex, point-to-point 방식이다. full-duplex란 전송이 양방향으로 동시에 일어날 수 있음을 의미하며 point-to-point란 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미한다. 즉, TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.

- ### HTTP 와 HTTPS 의 차이점

  #### HTTP의 문제점

  - **HTTP는 Plaintext 통신**이기 때문에 도청이 가능함
  - 통신 상대를 확인하지 않으므로 위장이 가능
  - 완전성을 증명할 수 없기 때문에 변조 가능

  #### 1. TCP/IP는 도청 가능한 네트워크이다

  TCP/IP 구조의 통신은 통신 경로에서 패킷을 수집하는 것만으로도 도청할 수 있다. HTTP는 암호화를 하지 않기 때문에 평문 메시지를 탈취당할 수 있다.

  ##### 해결 방법

  1. 통신 자체를 암호화 : SSL(Secure Socket Layer) / TLS(Transport Layer Security)라는 다른 프로토콜을 조합해 HTTP 통신 내용을 암호화한다. SSL을 조합한 HTTP를 HTTPS라고 한다.
  2. 콘텐츠를 암호화 : HTTP를 사용해서 운반하는 메시지에 포함되는 콘텐츠만 암호화. 받은 쪽에서 decoding 처리 필요

  #### 2. 통신 상대를 확인하지 않아 위장이 가능

  HTTP에 의한 통신에는 상대가 누구인지 확인하는 처리가 없으므로 누구나 리퀘스트를 보낼 수 있다. -> Dos 공격을 방지할 수 없다. 또한 클라이언트와 서버가 둘 다 의도한 곳으로 리스폰스를 보냈는지 확인할 수 없다.

  ##### 해결 방법

  SSL은 상대를 확인하는 수단으로 인증서(certificate: 신뢰할 수 있는 제 3자기관에 의해 발행됨)를 사용하여 해당 클라이언트와 서버가 실재한다는 것을 확인할 수 있다.

  #### 3. 완전성을 증명할 수 없기 때문에 변조가 가능

  완전성 = 정보의 정확성으로 상대방이 보낸 메시지가 중간에 변조되지 않았는지 확신할 수 없다. (Man-in-the-Middle 공격 등)

  ##### 해결 방법

  MD5, SHA-1 등의 해시 값을 확인하는 방법과 파일의 Digital Signature를 확인하는 방법이 필요하지만 확실하게 확인하는 방법은 아니다. 확실히 방지하기 위해서는 SSL을 사용한 HTTPS를 사용해야 한다.

  

  #### HTTPS

  HTTPS는 SSL의 껍질을 덮어 쓴 HTTP라고 할 수 있다. HTTPS는 새로운 애플리케이션 계층의 프로토콜이 아니라 통신하는 소켓 부분을 SSL/TLS 프로토콜로 대체하는 것이다.

  

- ### 웹 통신의 큰 흐름

  Chrome을 실행시켜 주소창에 특정 URL 값을 입력했을 때 일어나는 일

  #### in 브라우저

  1. 웹 브라우저가 URL을 해석한다.
  2. 조사된 의미에 따라 HTTP Request 메시지를 생성한다.
  3. 만들어진 메시지를 웹 서버로 전송한다.

  이 때 만들어진 메시지 전송은 브라우저가 직접 하는 것이 아니라 OS가 전달한다. 단, OS가 메시지를 보내기 위해서는 URL 도메인 명이 아니라 IP 주소가 필요한데 이 때 DNS 서버를 조회해야 한다.

  #### DNS(Domain Name Server) 조회

  1. DNS에 요청을 보내기 전에 먼저 Browser에 해당 Domain이 cache돼 있는지 확인한다. (Chrome의 경우 chrome://net-internals/#dns 에서 확인 가능)

  2. 없을 경우 로컬에 저장돼 있는 hosts파일에서 참조할 수 있는 Domain이 있는지 확인한다.

  3. 1, 2가 모두 실패 했을 경우 Network stack에 구성돼 있는 DNS로 요청을 보낸다. (DNS는 일반적으로 Local router, ISP의 캐싱 DNS)

  #### ARP(Address Resolution Protocol)로 대상의 IP와 Mac address를 알아냄

  ARP broadcast를 보내려면 Network stack library가 조회 할 대상 IP 주소와 ARP broadcast에 사용할 인터페이스의 MAC address를 알아야 한다.

   ARP cache는 대상 IP에 대한 ARP 항목을 확인해서 cache가 있을경우 MAC주소를 반환한다.

   ARP cache가 없는 경우 : 

  1. 대상 IP address가 local subnet에 있는지 확인하기 위해 routing table 조회

  2. 있는경우 subnet과 연관된 interface 사용, 없는 경우 기본 gateway의 subnet과 연관된 interface 사용

  3. Network library는 Link Layer(OSI Model Layer 2)에 ARP 요청을 보냄

  4. 응답에서 target의 MAC address와 IP address로 DNS 프로세스 다시 시작

  5. DNS에 53번 포트를 열어서 UDP 요청을 보낸다. (응답 데이터가 큰경우 TCP가 대신 사용)

  6. 로컬 / ISP DNS에 없는 경우 SOA(Service-oriented architecture)에 도달 할 때까지 재귀요청을 보내서 응답을 받는다.

  #### 대상과 TCP 통신을 통해 Socket을 연다

  이 때 TCP Connection Establishment를 위해 3-Way Handshaking. HTTPS를 이용할 경우 TLS Handshake가 추가됨

  #### in 프로토콜 스택, LAN 어댑터

  1. 프로토콜 스택(OS에 내장된 네트워크 제어용 소프트웨어)이 브라우저로부터 메시지를 받는다.
  2. 받은 메시지를 패킷 속에 저장하고 Sender 주소 등의 제어 정보를 덧붙인다.
  3. 패킷을 LAN 어댑터에 넘긴다.
  4. LAN 어댑터는 패킷을 전기 신호로 변환하고 신호를 LAN 케이블에 송출한다.

  프로토콜 스택은 통신 중 오류가 발생했을 때 제어 정보를 사용하여 고쳐 보내거나 각종 상황을 조절한다.


  #### in 허브, 스위치, 라우터

  1. LAN 어댑터가 송신한 패킷은 스위칭 허브를 경유하여 인터넷 접속용 라우터에 도착한다.
  2. 라우터는 패킷을 프로바이더(통신사)에 전달한다.
  3. 인터넷에 접속한다.

  #### in 방화벽, 캐시 서버

  1. 액세스 회선으로 통신사용 라우터로 운반되어 목적지로 도착한 패킷은 웹 서버 측의 LAN에 도착한다.
  2. 이 때 방화벽이 도착한 패킷을 검사하는데 웹 서버까지 가지 않아도 되는 패킷은 캐시 서버에 저장된다.

  #### in 웹 서버

  1. 패킷이 물리적인 웹 서버에 도착하면 웹 서버의 프로토콜 스택이 패킷을 추출해 메시지를 복원하고 웹 서버 애플리케이션에 넘긴다.
  2. 메시지를 받은 웹 서버 애플리케이션은 요청 메시지에 따른 데이터를 응답 메시지에 넣어 클라이언트로 응답한다.
  3. 왔던 방식을 거꾸로 거쳐 응답 메시지가 클라이언트로 전달된다.



## 💡 운영체제 [Link](https://github.com/JaeYeopHan/Beginner_for_interview/tree/master/OS)

- ### 프로세스와 스레드의 차이

  #### 프로세스 (Process)

  프로세스란 실행 중인 프로그램을 말한다. 프로세스는 메모리에 mapping되는 주소 공간, 코드, 데이터, 실행 스택, 스택 포인터(SP), 힙, 프로그램 카운터(PC) 등으로 구성되는 실행에 대한 OS의 추상화이다.

  ##### Process Table

  PCB(Process Control Block)을 포함한 테이블로 PID를 index로 해서 접근한다. PCB는 프로세스에 대한 모든 데이터를 포함하거나 가리키는 커다란 자료 구조이다. OS는 프로세스의 생성과 동시에 고유한 PCB를 생성해 프로세스에 대한 모든 정보를 PCB에 저장한다. 이는 프로세스가 CPU를 할당받아 작업을 처리하다가 Interrupt 또는 Scheduling에 의해 CPU를 반환하는 Process Context Switch가 일어날 때 모든 레지스터를 PCB에 저장하고 불러와야하기 때문이다.

  PCB에 저장되는 정보는 아래와 같다.

  - 프로세스 식별자(Process ID, PID) : 프로세스 식별번호
  - 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장
  - 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
  - CPU 레지스터
  - CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
  - 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
  - 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
  - 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등

  

  #### 스레드 (Thread)

  프로세스를 병렬적으로 사용하는 데에는 PCB의 할당, PCB 복사, OS의 Preccess 스케줄링 등의 문제가 있다. 이 때 프로세스를 여러 스레드로 분리하자는 개념이 도입되어 프로세스는 리소스 그룹과 실행 단위인 스레드로 나뉘게 된다. 

  즉, 스레드는 프로세스의 실행 단위이다. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 **프로세스 내의 주소 공간이나 자원을 공유**할 수 있다. 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 **스택**으로 구성된다. 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 그리고 열린 파일이나 신호와 같은 운영체제 자원들을 공유한다. 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 멀티스레딩이라고 한다. 이 경우 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터 값을 갖고 있다.

  


  #### 멀티 스레드의 장 단점

  스레드는 프로세스보다 가볍고 스레드 간 정보 교환이 빠르다. 특히 프로세스 내의 한 스레드가 block되어도 전체 프로세스가 영향을 받지 않는다. 스레드의 context switch 는 프로세스 context switch 와는 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.

  그러나 프로세스 내의 스레드들이 하나의 프로세스 자원에 접근하는 일에서 문제가 발생한다. 서로 다른 스레드가 자원에 접근해 변경할 때 다른 스레드가 그 자원을 사용하고 있다면 예기치 못한 문제가 발생할 수 있다. 따라서 멀티 스레딩 환경에서는 Synchronization이 필요하다.

  ### 멀티 스레드 vs 멀티 프로세스

  멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 Synchronization 문제를 안고 있다. 반면 멀티 프로세스 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재한다.

- ### 스케줄러의 종류

  프로세스를 스케줄링하기 위한 Queue는 3가지가 있다.

  - Job Queue: 현재 시스템 내에 있는 모든 프로세스의 집합
  - Ready Queue: 현재 메모리에 올라와 있으면서 CPU를 할당받아 실행되기를 기다리는 프로세스의 집합
  - Device Queue: Device I/O 작업을 대기하고 있는 프로세스의 집합

  따라서 각각의 Queue에 프로세스를 이동시키는 스케줄러도 3종류가 있다.

  - Job Scheduler(장기 스케줄러): 한정된 메모리에 많은 프로세스가 한거번에 올라올 경우 대용량 메모리(디스크)에 임시로 저장된다. 이 pool에 저장된 프로세스 중 메모리를 할당하여 Ready Queue로 보낼 프로세스를 결정한다.

    - 메모리와 디스크 사이의 스케줄링 담당
    - 프로세스에 memory 및 리소스 할당
    - 프로세스의 상태를 new -> ready로 

  - CPU Scheduler(단기 스케줄러)

    - CPU와 메모리 사이의 스케줄링을 담당
    - Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정
    - 프로세스에 CPU를 할당
    - 프로세스의 상태를 ready -> runnung -> waitng -> ready로

  - Swapper(중기 스케줄러)

    - 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아낸다. 이를 swapping이라고 한다.
    - 프로세스에게서 memory를 deallocate 한다.
    - 프로세스의 상태를 ready -> suspended로

    Process State - suspanded(stopped): 외부적인 이유로 프로세스의 수행이 정지된 상태로 메모리에서 내려간 것을 의미. 프로세스 전부 디스크로 swap out된다. blocked 상태는 다른 I/O 작업이 끝나면 ready로 돌아가지만 suspended는 외부적인 이유로 suspending 되었으므로 스스로 돌아갈 수 없다.

    

- ### CPU 스케줄러

  Ready Queue에 있는 프로세스를 스케줄링한다.

  #### FCFS(First Come First Served)

  먼저 오면 먼저 처리. Non-Preemptive 스케줄링 (일단 CPU 잡으면 끝날 때까지 반환하지 않음)

  문제점: 소요시간이 긴 프로세스가 한 번 잡아버리면 뒤에 빨리 끝나는 애들이 손해

  #### SJF(Shortest - Job - First)

  다른 프로세스가 먼저 도착했어도 CPU burst time 짧은 프로세스에게 먼저 할당. Non-Preemptive

  문제점: Starvation 문제. 무거운 프로세스는 계속 순위에서 밀려남

  #### SRTN(Shortest Remaining Time Next)

  Shortest job First의 Preemptive 버전. 남은 실행 시간이 가장 적은 프로세스를 선택한다.

  문제점: 사전에 프로세스들의 런타임을 계산해야 한다.

  #### Round-Robin Scheduling

  가장 오래되고 간단하고 공평하고 자주 사용되는 알고리즘이다. 각 프로세스는 quantum이라는 동일한 할당 시간을 받는다. quantum이 너무 길면 FCFS와 다를 게 없고 너무 짧으면 context switch가 많아져 overhead가 발생하므로 적당한 quantum 시간을 설정하는 것이 중요하다.

  #### Priority scheduling

  우선순위가 가장 높은 프로세스에 CPU를 할당한다. 우선순위는 정수로 작은 숫자가 우선이다.

  Preemptive 방식 - 더 높은 우선순위 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU를 선점

  Non-Preemptive 방식 - 더 높은 우선순위의 프로세스가 도착하면 Ready Queue의 head에 넣는다.

  문제점: Starvation - Proirity 낮으면 계속 못 받음

  #### 

- ### 동기와 비동기의 차이

  #### Blocking I/O Model (Synchronous)

  ![img](https://t1.daumcdn.net/cfile/tistory/22123438588F4A7405)

  User Level에서 수행할 수 없는 I/O 작업을 수행해야할 경우 System Call을 통해 Kernel Mode로 전환하여 OS에 작업을 요청해야 한다. 이 때 Context-switching이 일어나고 Kernel Level에서 해당 I/O 작업을 마치고 결과를 반환하면 그 때 block이 풀린다. 이렇게 한 프로세스의 작업이 끝날 때까지 block하고 기다리는 것을 Synchronous Model 또는 Blocking I/O Model이라고 한다.

  #### Non-Blocking I/O Model 

  ![img](https://t1.daumcdn.net/cfile/tistory/221EB538588F4AF01E)

  한정된 CPU 자원을 사용하는 프로세스가 block되어 다른 프로세스들이 CPU를 할당받지 못하는 것은 자원의 낭비이므로 non-blocking 방식이 만들어졌다. non-blocking 모델은 I/O 작업을 하는 동안 유저 프로세스의 작업을 중단시키지 않는다. System call로 Kernel에 I/O 작업을 전달하고 처리 상황에 상관 없이 바로 결과를 반환한다. 이 구현의 문제점은 애플리케이션에서 polling을 하며 I/O 작업이 끝났는지 계속해서 확인을 해야한다는 것이다.

  

  #### Asynchronous I/O Model

  ![img](https://t1.daumcdn.net/cfile/tistory/2519C04F588F4C8003)

  Event-driven Model이라고도 불리며 polling을 통해 계속해서 확인하는 것이 아니라 Kernel에서 I/O 작업이 완료되었을 때 System Interrupt를 발생시켜 알려주면 Handler로 처리한다.

  

- ### 프로세스 Synchronization

  위에서 멀티프로세싱/멀티스레딩 환경에서 shared resource에 접근할 때 다른 프로세스/스레드가 해당 자원에 접근하지 못하도록 Synchronization이 필요하다고 했다.

  #### Race Condition

  둘 혹은 이상의 프로세스들이 하나의 공유 데이터에 접근하고 수정하여 output이 타이밍에 따라 예측할 수 없게 되는 문제.

  #### Critical Section(Critical Regions)

  공유되는 자원에 접근하는 코드 영역

  #### CSP(Critical Section Problem) 해결을 위한 Requirments

  - Mutual Exclusion

    Critical Section에는 최대 1개의 스레드만 들어가있을 수 있다.

  - Bounded Waiting(no starvation)

    Critical Section 진입을 기다리고 있던 스레드는 진입 가능한 상황이 됐을 때 즉각 진입할 수 있어야 한다.

  - Progress

    스레드 T가 critical section에서 나왔는데도 T 때문에 다른 스레드가 critical section에 들어가지 못하면 안 된다.

  #### CSP 해결책

  ##### Lock

  global 변수인 lock 변수를 사용한다. 어떤 프로세스가 critical section에 진입해야할 때 lock이 0이면 들어갈 수 있고 critical section에 진입하자마자 lock을 1로 변경해 다른 프로세스의 진입을 막는다.

  - lock을 걸기 전에 interrupt가 걸려버리면 둘 다 c/s에 진입하는 mutex 위반 이 생길 수 있고 lock을 풀기 전에 interrupt가 걸려 다른 프로세스가 진입했는데 lock이 걸려있어 진입을 못 하는 progress 위반이 생길 수 있다. 이를 방지하기 위해 atomic한 TSL(Test and Set Lock)을 사용한다. 이는 중간에 interrupt를 받지 않고 하드웨어가 TSL instruction을 수행할 것을 보장한다.

  그러나 lock은 busy wating을 해야해서 효율성이 너무 떨어진다.

  ##### Semaphores

  down, up이라는 2개의 연산을 통해 atomic하게 조작되는 변수.

  down(&semaphore): semaphore -1 을 수행하고 semaphore가 0보다 같거나 작으면 wait(block)시킨다. (atomic) wait에서 깨워지면 다시 down 연산을 수행한다.

  up(&semaphore): semaphore +1 을 수행하고 다른 스레드가 critical section에 진입하도록 허용한다. (down에서 기다리고 있는 스레드 하나를 깨운다.)

  ##### Monitors

  - 고급 언어의 설계 구조물로서, 개발자의 코드를 상호배제 하게끔 만든 추상화된 데이터 형태이다.
  - 공유자원에 접근하기 위한 키 획득과 자원 사용 후 해제를 모두 처리한다. (세마포어는 직접 키 해제와 공유자원 접근 처리가 필요하다. )

  

- ### 메모리 관리 전략

  물리적 메모리를 프로세스에 직접 공개하는 것은 위험하다.

  1. 사용자 프로그램이 메모리의 모든 공간에 접근할 수 있으면 OS를 지워버릴 수도 있다.
  2. 한 번에 여러 프로그램을 돌리기 힘들다.

  따라서 메모리에 대한 추상화가 필요해져서 나온 개념이 address space이다. address space란 프로세스가 사용할 수 있는 주소 범위를 말하며 각 process는 다른 process와 구분되는 고유의 address space를 가진다.

  #### Base and Limit Register

  각각의 프로세스가 가지는 address space를 실제의 물리적 메모리 공간에 매핑하는 것을 dynamic relocation이라고 하는데 이 때 base register, limit register라는 특별한 레지스터가 사용된다.

  Base register: 프로그램이 load된 위치의 물리적 메모리 주소값(프로그램은 0이라고 시작하지만 실제로는 base register 값에 위치한다.) 프로그램의 virtual address에 base register를 더하면 실제 물리적 메모리 주소가 나오므로 relocation 문제가 해결된다.

  Limit register: 프로그램의 길이

  Relocation의 단점은 매번 메모리를 접근할 때마다 limit reg를 안 넘는지 검사하고 relocation 연산(base reg 더하기)을 해야해서 오래 걸린다는 것이다.

  #### Swapping

  컴퓨터의 물리적 메모리가 모든 프로세스를 돌리기에 크기가 부족할 때 memory overhead가 일어난다고 한다. memory overhead를 해결하기 위해서 가장 간단한 방법을 프로세스 전체를 디스크로 swap out했다가 여유가 생기면 다시 swap in 하는 swapping 방법이다. 다른 전략으로는 프로그램의 일부만을 메모리에 올려서 실행하는 virtual memory 전략이 있다.

  Swapping을 하며 프로세스가 메모리에 적재되었다가 제거되는 일이 반복되면 메모리 중간에 남는 공간이 생긴다. 이 문제를 Fragmentation이라고 한다. Fragmentation은 memory compaction으로 해결할 수 있는데 CPU 시간을 많이 잡아먹어 효율적이지 않다.

  #### 

- ### 가상 메모리

  virtual memory가 도입되기 전에는 메모리의 크기가 프로그램의 크기보다 반드시 커야 프로그램을 메모리에 올려서 실행시킬 수 있었다. 그러나 프로그램이 발전하면서 메모리의 용량을 초과하게 되면서 불필요한 프로그램 전체가 메모리에 올라가는 것을 방지하고자 virtual memory가 도입되었다.

  virtual memory는 프로세스를 disk와 memory에 나눠서 저장한다. 각 프로그램이 가진 address space의 일부(page)만 memory에 적재하는 것이다. 각 page들은 연속된 주소를 가지고 있고 물리적 메모리에 매핑된다.

  #### Paging

  virtual(logical) 주소를 physical주소로 변환하여 relocation하려면 프로그램 전체가 메모리에 올라와야 하는 Swapping 방식의 단점을 보완하기 위해 Paging이 도입되었다.

  MMU에 의해 만들어진 virtual address들은 virtual address space를 형성한다. 가상 메모리를 사용하면 virtual address에 접근 시 MMU를 통해 physical address로 접근된다.

  가상 메모리 공간은 page로 이루어져있고 각 페이지에 매핑되는 물리적 메모리 공간을 page frame이라고 한다.

  #### Page Tables

  OS가 관리하는 page tagle은 virtual page를 page frame과 매핑하기 위해 존재하며 page 당 하나의 PTE(Pate Table Entry)를 갖는다.

  Paging의 2가지 개선해야할 점으로

  1. virtual address -> physical address로의 매핑이 빨라야한다. (page table을 거쳐 page fault시 memory까지 갔다옴)
  2. virtual address space가 커지면 page table이 메모리에서 많은 영역을 차지한다.

  Paging을 빠르게 하기 위해서 TLB(Translation Lookaside Buffer)가 도입됐다. MMU 안에 작은 테이블로 존재하는 TLB는 virtual memory 접근 시

  - TLB hit - page table까지 안 가고 바로 page frame 접근
  - TLB miss - page table 가서 제일 안 쓰이는 거랑(LRU) page 교체 -> page table에도 없으면 Page Fault -> OS

  Context Switch가 일어날 경우 Page Table도 교체되므로 TLB도 비워지고 채워지는 동안 계속 TLB miss가 발생한다.

  #### Page 교체 알고리즘

  Page fault가 발생하면 OS는 요구된 page를 적재하기 위해서 메모리에서 제거할 page를 선택해야 한다. 이런 방식을 Demanding Paging이라고 하는데 Page fault가 일어나면 그때 비로소 frame을 할당하는 방식을 말한다.

  ##### FIFO 페이지 교체

  가장 간단한 페이지 교체 알고리즘으로 FIFO(first-in first-out)의 흐름을 가진다. 즉, 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다는 것이다.

  - 장점
    - 이해하기도 쉽고, 프로그램하기도 쉽다.
  - 단점
    - 오래된 페이지가 항상 불필요하지 않은 정보를 포함하지 않을 수 있다(초기 변수 등)
    - 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있다.
    - `Belady의 모순`: 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.

  ##### 최적 페이지 교체(Optimal Page Replacement)

  `Belady의 모순`을 확인한 이후 최적 교체 알고리즘에 대한 탐구가 진행되었고, 모든 알고리즘보다 낮은 페이지 부재율을 보이며 `Belady의 모순`이 발생하지 않는다. 이 알고리즘의 핵심은 `앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체`하는 것이다. 주로 비교 연구 목적을 위해 사용한다.

  - 장점
    - 알고리즘 중 가장 낮은 페이지 부재율을 보장한다.
  - 단점
    - 구현의 어려움이 있다. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문이다.

  ##### LRU 페이지 교체(LRU Page Replacement)

  `LRU: Least-Recently-Used`
  최적 알고리즘의 근사 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.

  - 특징
    - 대체적으로 `FIFO 알고리즘`보다 우수하고, `OPT알고리즘`보다는 그렇지 못한 모습을 보인다.

  ##### LFU 페이지 교체(LFU Page Replacement)

  `LFU: Least Frequently Used`
  참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘이다.

  - 특징
    - 어떤 프로세스가 특정 페이지를 집중적으로 사용하다, 다른 기능을 사용하게되면 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생할 수 있다
    - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.

  ##### MFU 페이지 교체(MFU Page Replacement)

  `MFU: Most Frequently Used`
  참조 회수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반한다.

  - 특징
    - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.

   

  #### Segmentation

  Paging처럼 virtual memory와 physical memory를 같은 크기의 블록이 아닌 서로 다른 크기의 논리적 단위인 segment로 분할하는 것.... ㅁㄹ Segment도 paging을 해서 쓴다고 배웠다.

  

- ### 캐시의 지역성

  - Locality
  - Caching line



## 💡 데이터베이스 [Link](https://github.com/JaeYeopHan/Beginner_for_interview/tree/master/Database)

- ### 데이터베이스

  #### 데이터베이스 관리 시스템을 사용하는 이유

  데이터베이스 이전에는 파일 시스템을 이용해 데이터를 관리했는데 이는 데이터 종속성과 중복성, 무결성 문제를 야기했다.

  #### DBMS의 특징

  1. 데이터의 독립성(Data Independency)

     - 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.
     - 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양항 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.

  2. 데이터의 무결성(Data Integrity)

     여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.

  3. 데이터의 보안성(Data Security)

     인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.

  4. 데이터의 일관성(Data Consistency)

     연관된 정보를 논리적은 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.

  5. 데이터 중복(Data Redunancy)

     최소화 데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

- ### DBMS의 정의

  DBMS(Database Management Sysyem): 응용 프로그램과 데이터 사이의 중재자로서 모든 응용프로그램들이 데이터베이스를 공용할 수 있게 관리해주는 소프트웨어 시트템

  #### DBMS의 필수 기능 3가지

  1. 정의(definition): 하나의 물리적 구조의 데이터베이스로 여러 사용자의 요구를 지원할 수 있도록 적절한 데이터베이스 구조를 정의하는 기능
  2. 조작(manipulation): 사용자의 요구에 따라 체계적으로 데이터베이스 접근, 조작하는 인터페이스 수단 제공 -> SQL 언어
  3. 제어(control): 공용 목적으로 관리되는 데이터베이스의 정확성과 안정성 유지

- ### Index

  - Index 란 무엇인가
  - Index 의 자료구조
  - Primary index vs Secondary index
  - Composite index
  - Index 의 성능과 고려해야할 사항

- ### 정규화에 대해서

  - 정규화 탄생 배경
  - 정규화란 무엇인가
  - 정규화의 종류
  - 정규화의 장단점

- ### Transaction

  - 트랜잭션(Transaction)이란 무엇인가?
  - 트랜잭션과 Lock
  - 트랜잭션의 특성
  - 트랜잭션의 상태
  - 트랜잭션을 사용할 때 주의할 점

- ### Statement vs PreparedStatement

- ### NoSQL

  - 정의
  - CAP 이론
    - 일관성
    - 가용성
    - 네트워크 분할 허용성
  - 저장방식에 따른 분류
    - Key-Value Model
    - Document Model
    - Column Model

#### 추가자료

- [DBMS 는 어떻게 트랜잭션을 관리할까?](https://d2.naver.com/helloworld/407507)



## 💡 Design Pattern [Link](https://github.com/JaeYeopHan/Beginner_for_interview/tree/master/DesignPattern)

- Singleton



## 💡 Algorithm (알고리즘) [Link](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Algorithm)

- 손코딩 및 코딩 테스트 대비 => 대부분의 내용이 코드이기 때문에 별도의 [Java Algorithm Training Repository](https://github.com/JaeYeopHan/algorithm_basic_java)에 저장합니다.
- 코딩 테스트를 위한 Tip
- 문제 해결을 위한 전략적 접근
- Sorting Algorithm
- Prime Number Algorithm



[(목차로 돌아가기)](https://github.com/JaeYeopHan/Interview_Question_for_Beginner#technical-interview-guidelines-for-beginners)



# Part 2. Language

## 💎 JavaScript [Link](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/JavaScript)

* ### 자바스크립트란

  초창기 자바스크립트는 웹 페이지의 보조적인 기능을 수행하기 위해 한정적 용도로 사용되었으나 1999년 XMLHttpRequest라는 이름으로 ajax가 등장한 후 웹 페이지를 필요한 부분만 렌더링할 수 있게 되었고 이로 인해 웹 브라우저에서도 네이티브 애플리케이션과 유사한 빠른 성능과 부드러운 화면 전환이 가능하게 되었다. 자바스크립트의 발전으로 빠르게 동작하는 자바스크립트 엔진이 요구되어 2008년 구글의 V8 자바스크립트 엔진이 등장하며 과거 웹 서버에서 수행되던 역할들이 대거 클라이언트로 이동하는 계기가 된다. Node.js의 등장으로 브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를 브라우저 외의 환경에서도 동작할 수 있게 되었다. Node.js는 비동기(asynchronous) I/O를 지원하며 단일 스레드(Single Thread) 이벤트 루프 기반으로 동작해 요청 처리의 성능이 좋다. 이에 자바스크립트는 크로스 플랫폼을 위한 중요한 언어로 주목받아 웹은 물론 모바일 하이브리드 앱(PhoneGap, Ionic), 서버 사이드(Node.js), 데스크톱(Electron), 머신러닝(Tenserflow.js), 로보틱스 프로그래밍 언어로 인기를 끌고 있다.

  #### JavaScript와 ECMAScript

  ECMAScript는 자바스크립트의 표준 사양인 ECMA-262를 말하며 프로그래밍 언어의 타입, 값, 객체와 프로퍼티, 함수, 표준 built-in 객체 등 핵심 문법(core syntax)을 규정한다. 각 브라우저 제조사는 ECMAScript를 준수하여 브라우저에 내장되는 자바스크립트 엔진을 구현한다.

  자바스크립트는 일반적으로 프로그래밍 언어로서 기본 뼈대(core)를 이루는 ECMAScript와 브라우저가 별도로 지원하는 Client-side Web API로 이루어진다. 즉 자바스크립트 = ECMASCript(core syntax) + Web API(DOM, BOM, Canvas, XMLHttlRequest, Fetch, SVG, Web Storage, Web worker 등)을 아우르는 개념이다.

  

* ### 변수 선언 - Hoisting

  변수 선언(Variable declaration)이란 변수를 생성하는 것을 말한다. 변수를 사용하려면 반드시 선언이 필요하고 이 때 var, let, const 키워드를 사용한다.

  #### `var` 키워드로 선언한 변수의 문제점

  1. 중복 선언 가능

     `var` 키워드로 선언한 변수는 중복 선언이 가능하다.

     같은 스코프 내에서 변수를 중복 선언하면 나중에 선언된 변수는 선언문이 아닌 할당문처럼 동작하며 이 때 에러가 발생하지 않아 의도치 않게 변수의 값이 변경될 수 있다.

  2. 함수 레벨 스코프만 지원

     var 키워드로 선언한 변수는 오로지 함수 코드 블록만을 local 스코프로 인정한다. 따라서 if문이나 for문 등에서 선언한 var 변수는 모드 전역 변수가 된다.

  3. 변수 호이스팅

     `var` 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다. `var score;`는 선언 단계를 통해 변수 이름 score를 등록하고, 초기화 단계를 통해 변수 score에 암묵적으로 `undefined`를 할당하여 초기화한다.

     > - 선언 단계(Declaration phase) : 실행 컨텍스트에 변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다.
     >
     > - 초기화 단계(Initialization phase) : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당한다.

     선언하지 않은 식별자에 접근하면 ReferenceError가 발생한다.  ReferenceError는 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러다.

  자바스크립트 엔진은 소스 코드를 한 줄씩 **실행하기 전에 코드의 평가 과정을 거칠 때 변수 선언문을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 미리 실행**하기 때문에 소스 코드 상에서 선언하기 이전의 식별자를 참조해도 에러가 나지 않는다. 이처럼 **변수 선언문이 코드의 맨 위로 끌어 올려진 것처럼 동작하는 자바스크립트의 특징을 변수 호이스팅(Variable Hoisting)이라고 한다**.

  이 때 주의할 점은 자바스크립트 엔진이 평가 과정에서 실행하는 것은 오직 선언문뿐이고 할당문은 포함되지 않는다는 것이다.

  ```javascript
  foo();
  function foo(){
    console.log('ok');	//	함수 선언문
  };
  // Ok
  
  foo();
  var foo = function foo(){
    console.log('ok');	// 함수 표현식
  };
  // Syntax error!
  ```

  #### let, const

  `var` 키워드의 이러한 문제점을 보완하기 위해서 ES6에서 도입되었다. `let`, `const` 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행된다. 즉, 런타임 이전 **평가 과정에서 암묵적으로 선언 단계만 먼저 실행**되고 **초기화 단계는 런타임에 변수 선언문에 도달했을 때 실행**된다. 따라서 런타임에 선언 단계만 수행된 let, const 변수에 선언문 전에 접근하면 ReferenceError가 발생한다. 따라스 스코프의 시작 지점부터 변수 선언문을 만나라 때까지 변수를 참조할 수 없는데 이 구간을 TDZ(Temporal Dead Zone)이라고 한다.

  `let` 키워드로 선언한 변수는 hoisting이 되지 않는 게 아니라, 선언문을 만났을 때 initialization phase를 진행해 hoisting되지 않는 것처럼 보이게끔만 한다.

  #### 할당

  **변수 선언은 소스 코드가 순차적으로 실행되기 이전, 즉 런타임 이전에 먼저 실행되지만 값의 할당은 소스 코드가 순차적으로 실행되는 시점인 런타임에 실행된다.**

  변수에 값을 할당할 때 이전 값이 저장되어있던 메모리 공간의 값을 수정하는 것이 아니라 새로운 메모리 공간을 할당하고 새로 할당된 메모리 공간을 참조하는 방식으로 진행된다.

* ### 데이터 타입

  원시 타입(primitive type)

  - 숫자(number) 타입: 숫자. 정수와 실수 구분없이 하나의 숫자 타입만 존재 (모두 실수)
  - 문자열(string) 타입: 문자열
  - 불리언(boolean) 타입: 논리적 참(true)과 거짓(false)
  - undefined 타입: var 키워드로 선언된 변수에 암묵적으로 할당되는 값
  - null 타입: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값
  - Symbol 타입: ES6에서 새롭게 추가된 7번째 타입 - 주로 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키(property key)를 만들기 위해 사용

  객체 타입 (object/reference type): 객체, 함수, 배열 등

  #### 동적 타입 언어

  **자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.** 이러한 특징을 **동적 타이핑(Dynamic typing)**이라 하며 자바스크립트를 정적 타입 언어와 구별하기 위해 **동적 타입(Dynamic/Weak type) 언어**라 부른다. 대표적인 동적 타입 언어는 자바스크립트, Python, PHP, Ruby, Lisp, Perl 등이 있다.

* ### 객체

  자바스크립트는 객체 기반 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 모든 것이 객체이다. 원시 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다.

  객체는 0개 이상의 프로퍼티의 집합이며 프로퍼티는 키(key)와 값(value)으로 구성된다. 자바스크립트에서 사용할 수 있는 모든 값이 프로퍼티의 값이 될 수 있다. 자바스크립트에서 함수는 일급 객체이므로 함수도 프로퍼티의 값이 될 수 있다. 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메소드(method)라 부른다.

  - 프로퍼티: 객체의 상태를 나타내는 값(data)
  - 메소드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

  #### 객체 생성 방법

  - 객체 리터럴
  - Object 생성자 함수
  - 생성자 함수
  - Object.create 메소드
  - 클래스 (ES6)

  #### 프로퍼티

  - 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값
  - 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값

  프로퍼티 키가 반드시 식별자 네이밍 규칙을 따라야하는 것은 아니지만 식별자 네이밍 규칙을 따르지 않는 프로퍼티는 생성 시 `'프로퍼티'`로 감싸야하고 접근 시 `객체.프로퍼티`가 아닌 `객체['프로퍼티']`로 접근해야한다.

  #### 메소드 축약 표현

  ES6의 메소드 축약 표현으로 정의한 메소드는 프로퍼티에 할당한 함수와 다르게 동작한다.

* ### 원시 값과 객체 비교

  | Primitive Type      | Object Type                      |
  | :------------------ | :------------------------------- |
  | immutable value     | mutable value                    |
  | 변수에 실제 값 저장 | 변수에 참조 값(메모리 주소) 저장 |
  | Pass by value       | Pass by reference                |

  #### immutable value

  원시 타입의 값, 원시 값은 변경 불가능한 값(immutable value)이다. 변경 불가능하다는 것은 재할당할 수 없다는 것과는 다르다. 변경 불가능한 값이라는 것은 값이 저장되어 있는 메모리 공간을 직접 수정할 수 없다는 것이다. 변수에 원시 값을 재할당하면 이전에 참조하고 있던 메모리 공간을 버리고 새로운 원시 값을 참조하게 된다. 이런 특성을 **불변성(immutability)**이라고 한다. 불변성을 갖는 값을 할당한 변수는 재할당 외에 변수 값을 변경할 수 없다.

  자바스크립트에서는 문자열도 원시타입이므로 문자열이 생성된 후 변경할 수 없다. 자바스크립트에서 문자열은 유사 배열이므로 인덱스를 사용해 각 문자에 접근할 수 있지만 하나의 문자열을 변경한다고 해서 반영되지 않고 에러도 발생하지 않는다.

  #### Pass by Value

  값에 의한 전달. 변수에 원시값을 갖는 변수를 할당할 때 할당 받는 변수에 할당되는 변수의 원시값 자체를 복사해 새로 할당한 메모리 주소를 전달한다.

  이와 다르게 객체는 Pass By Reference, 참조에 의한 전달로 변수에 객체 값을 갖는 변수를 할당할 때 할당되는 변수의 메모리 주소만 복사되어 전달된다. 따라서 원시 값을 갖는 변수들은 각각 다른 메모리 공간을 가리키지만 객체 값을 복사받은 변수들은 하나의 메모리 공간을 참조하게 된다.

  > #### 얕은 복사(shallow copy)와 깊은 복사(deep copy)
  >
  > 객체를 프로퍼티 값으로 갖는 객체의 경우, 얕은 복사는 한 단계까지만 복사하는 것을 말하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말한다.
  > 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체이다. 즉, 원본과 복사본은 참조값이 다른 별개의 객체이다. 하지만 얕은 복사는 객체에 중첩되어 있는 객체의 경우, 참조값을 복사하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하여 원시 값처럼 완전한 복사본을 만든다는 차이가 있다.

* ### 화살표 함수

  ES6에서 새롭게 도입된 화살표 함수는 생성자 함수로 사용할 수 없으며 기존의 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다.

* ### 스코프

  **모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프(Scope, 유효범위)라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다.**

  자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야 할 것인지 결정한다. 즉, 스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이다.

  > #### 코드의 문맥(Context)과 환경(Environment)
  >
  > “코드가 어디서 실행되며 주변에 어떤 코드들이 있는지”를 환경(Environment)이라고 부른다. 즉, 코드의 문맥(Context)은 환경들로 이루어진다. 이를 구현한 것이 “실행 컨텍스트(Execution context)”이며 모든 코드는 실행 컨텍스트에서 평가되고 실행된다. 

  스코프는 함수의 중첩에 의해 계층적 구조를 가지며 스코프 체인을 형성한다. 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작해 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.

  스코프 체인은 물리적인 메모리에 존재하는데, 자바스크립트 엔진은 코드를 실행하기 전에 Lexical Environment를 생성한다.

  > #### Lexical Environment
  >
  > 스코프 체인은 실행 컨텍스트(Executation Context)의 렉시컬 환경(Lexical Environment)를 단방향으로 연결한 것이다. 전역 렉시컬 환경은 코드가 로드되고 바로 생성되고 함수의 렉시컬 환경은 함수가 호출되고 바로 생성된다.

  변수의 선언 시 식별자가 등록되는 곳이 바로 렉시컬 환경이다. 자바스크립트 엔진은 스코프 체인을 렉시컬 환경을 연결해 구현한다.

* ### 생성자 함수

  객체를 여러 개 생성해야할 때 객체 리터럴로만 생성하는 것은 코드의 중복을 야기한다. 생성자 함수로 객체를 생성하면 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.

  생성자 함수는 일반 함수와 동일하게 정의하고 단지 호출 시 **new 연산자와 함께 호출하면 생성자 함수로 동작**한다. 주의해야한 점은 생성자 함수를 new 연산자 없이 호출하면 일반 함수로 동작한다는 것이다.

  ```javascript
  function Circle(radius) {
    this.radius = radius;
    this.getDiameter = function() {
      return 2 * radius;
    }
  }
  const circle = new Circle(5);
  ```

  #### this

  this는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수(Self-referencing variable)이다. this가 가리키는 값, 즉 t**his 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.**

  | 함수 호출 방식       | this가 가리키는 값                     |
  | :------------------- | :------------------------------------- |
  | 일반 함수로서 호출   | 전역 객체                              |
  | 메소드로서 호출      | 메소드를 호출한 객체(마침표 앞의 객체) |
  | 생성자 함수로서 호출 | 생성자 함수가 (미래에) 생성할 인스턴스 |

  #### 생성자 함수의 객체 생성 과정

  1. 생성자 함수가 호출되면 암묵적으로 빈 객체를 생성하고 this에 이 객체를 바인딩한다. 이 객체가 생성자 함수가 생성한 instance이다. 이 과정은 런타임 이전에 실행된다.
  2. this 바인딩이 끝난 후 코드를 한줄씩 실행하며 this에 바인딩된 인스턴스를 초기화 한다. 프로퍼티나 메소드를 추가하고 고정값을 할당한다.
  3. 생성자 함수 내부의 모든 코드가 실행되면 암묵적으로 this를 반환한다. 만약 생성자 함수 내부에 명시적으로 return 문이 기술되어있다면 return 문에 명시한 객체가 반환되므로 생성자 함수 안에는 return 문을 쓰지 않는다. (그러나 이 때 원시 값을 반환하면 무시하고 this가 반환된다.)

* ### 프로토타입

  자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어다. ES6에서 클래스가 도입되었으나 자바스크립트의 클래스는 사실 함수이며 기존 프로토타입 기반의 인스턴스를 생성한다.

  **자바스크립트는 프로토타입(prototype)을 기반으로 상속을 구현한다.**

  #### 프로토타입 객체

  프로토타입 객체(prototype)은 객체 간의 상속을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 부모 객체 역할을 하는 체로, 다른 객체에 공유 프로퍼티를 제공한다. 프로토타입을 상속받은 자식 객체는 부모객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.

  모든 객체는 `[[Prototype]]` 내부 슬롯을 가지며, 내부 슬롯의 값으로 프로토타입 객체의 참조를 저장한다. 프로토타입은 객체의 생성 방식에 의해 결정된다.

  객체 리터럴로 생성된 객체의 프로토타입은 **Object.prototype**이고, 생성자 함수에 의해 생성된 객체의 프로토타입은 **자신을 생성한 함수의 prototype 프로퍼티**이다.

  **모든 객체는 하나의 프로토타입을 가지며 모든 프로토타입은 생성자 함수와 연결되어 있다.** 이는 객체와 프로토타입, 생성자 사이를 연결한다.

  ![Prototype Connection](https://user-images.githubusercontent.com/48080762/57820069-2042f600-77c6-11e9-8292-68c91244925a.png)

  - Constructor Function : prototype property가 prototype object를 가리킴
  - Constructor Function.prototype Object : constructor property가 constructor function를 가리킴
  - Obejct : __ proto __ Accessor property로 자신을 생성한 함수의 prototype Obect에 접근할 수 있음 (내부 슬롯 `[[Prototype]]`이 가리키고 있음)

  #### 객체의 `__proto__` 접근자 프로퍼티와  함수 객체의 prototype 프로퍼티

  함수 객체는 `__proto__` 접근자 프로퍼티 외에 `prototype` 프로퍼티도 소유한다.

  `__proto__`는 모든 객체가 가지는 자신의 프로토타입 접근자 프로퍼티이고, `prototype` 프로퍼티는 함수 객체가 자신이 생성할 인스턴스에 할당하는 프로토타입이다.

  | 구분      | prototype 프로퍼티                                   | `__proto__` 접근자 프로퍼티                       |
  | :-------- | :--------------------------------------------------- | :------------------------------------------------ |
  | 소유      | 함수 객체                                            | 모든 객체                                         |
  | 값        | 프로토타입의 참조값                                  | 프로토타입의 참조값                               |
  | 사용 주체 | 생성자 함수                                          | 모든 객체                                         |
  | 사용 목적 | 자신이 생성할 객체의 프로토타입을 할당하기 위해 사용 | 자신이 상속받은 프로토타입에 접근하기 위해서 사용 |

* ### 전역 객체

  전역 객체는 코드가 실행되기 이전 단계에서 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않는 최상위 객체이다.

  전역 객체는 브라우저 환경에서는 window, Node.js 환경에서는 global이라고 불린다.

  전역 객체는 표준 빌트인 객체(Object, String, Number, Function, Array...)들과 환경에 따른 호스트 객체, 그리고 **`var` 키워드로 선언한 전역 변수와 전역 함수**를 프로퍼티로 갖는다.

* ### this 키워드

  this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메소드를 참조할 수 있다. **자바스크립트의 this는 함수가 호출되는 방식에 따라 this에 바인딩될 값, 즉 this 바인딩이 동적으로 결정된다.** 또한 엄격 모드(strict mode) 역시 this 바인딩에 영향을 준다. strict mode에서 일반 함수의 this는 전역 객체가 아닌 undefined이다.

  #### 함수 호출 방식과 this 바인딩

  함수를 호출하는 방식은 아래와 같이 다양하다.

  1. 일반 함수 호출: this는 전역 객체 window를 가리킴 (엄격 모드에서는 undefined)
  2. 메소드 호출: this는 메소드를 호출한 객체를 가리킴
  3. 생성자 함수 호출: this는 생성자 함수가 생성한 인스턴스를 가리킴
  4. Function.prototype.apply/call/bind 메소드에 의한 간접 호출: this는 파라미터에 의해 결정된다.

  **함수가 선언된 환경과 관계 없이 호출 방식에 따라서 this 바인딩이 결정된다는 것을 유의**하자.

  | 함수 호출 방식                                             | this 바인딩                                                  |
  | :--------------------------------------------------------- | :----------------------------------------------------------- |
  | 일반 함수 호출                                             | 전역 객체                                                    |
  | 메소드 호출                                                | 메소드를 호출한 객체                                         |
  | 생성자 함수 호출                                           | 생성자 함수가 (미래에) 생성할 인스턴스                       |
  | Function.prototype.apply/call/bind 메소드에 의한 간접 호출 | Function.prototype.apply/call/bind 메소드에 인자로 전달한 객체 |

* ### 실행 컨텍스트

  | 소스 코드의 타입         | 설명                                                         |
  | :----------------------- | :----------------------------------------------------------- |
  | 전역 코드(Global code)   | 전역에 존재하는 소스 코드를 말한다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
  | 함수 코드(Function code) | 함수 내부에 존재하는 소스 코드를 말한다. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
  | eval 코드(Eval code)     | 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스 코드를 말한다. |
  | 모듈 코드(Module code)   | 모듈 내부에 존재하는 소스 코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다. |

  소스 코드(실행 가능한 코드, executable code)를 4가지 타입으로 구분하는 이유는 소스 코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문이다.

  1. 전역 코드: 전역 코드는 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 한다. 그리고 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메소드로 바인딩하고 참조하기 위해 전역 객체와 연결되어야 한다. 이를 위해 **전역 코드가 평가되면 전역 실행 컨텍스트가 생성**된다.
  2. 함수 코드: 함수 코드는 지역 스코프를 생성하고 지역 변수와 매개 변수를 관리해야 한다. 그리고 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 한다. 이를 위해 **함수 코드가 평가되면 함수 실행 컨텍스트가 생성**된다.
  3. eval 코드: eval 코드는 엄격 모드(strict mode)에서 자신만의 독자적인 스코프를 생성한다. 이를 위해 eval 코드가 평가되면 eval 실행 컨텍스트가 생성된다.
  4. 모듈 코드: 모듈 코드는 모듈 별로 독립적인 스코프를 생성한다. 이를 위해 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성된다.

  #### 소스코드의 평가와 실행

  모든 소스 코드는 실행에 앞서 평가 과정을 거치며 코드 실행을 위한 준비를 한다. 즉, 자바스크립트는 소스 코드를 평가와 실행으로 나누어 처리한다.

  ##### 1. 코드의 평가 과정

  코드의 평가 과정에서 **실행 컨텍스트가 생성**된다.

  변수, 함수, 클래스 등의 **선언문이 우선 평가되고 그 결과가 실행 컨텍스트에 등록**된다.

  > #### Evaluation and Hoisting
  >
  > `var` 키워드로 선언한 변수 선언문은 평가되어 변수명(식별자)이 실행 컨텍스트에 등록된다. 이 때 1. 선언 단계(Declaration Phase)로 변수명을 등록하고 2. 초기화 단계(Initialazation Phase)로 변수명에 `undefined`를 할당한다. 이는 자바스크립트 엔진에 변수의 존재를 알려 변수를 관리하도록 한다.
  >
  > `let`이나 `const` 키워드로 선언한 변수 선언문은 평가되어 실행 컨텍스트에 등록될 때 1. 선언 단계만 거친다. 2. 초기화 단계로 `undefined`를 할당하는 것이 아니라 자바스크립트 엔진이 알고 있는 특별한 값을 할당하여 초기화 이전에 해당 값을 참조하면 `ReferenceError: Cannot access 'x' before initialization`을 발생시킨다. `let`이나 `const` 키워드로 선언한 변수의 **2. 초기화 단계는 코드의 실행 중 선언문을 실행시킬 때 이루어진다.**
  >
  > 함수 선언문의 경우 **함수명과 동일한 변수명을 실행 컨텍스트에 등록**하고, **즉시 함수 객체를 생성해서 변수명에 할당**한다.
  >
  > 함수 호출시 진행되는 함수 코드의 평가에서는 parameter와 내부 코드의 선언문을 평가한다. 이 때 **parameter는 `var` 키워드로 선언한 변수로 취급되어 `undefined`로 초기화**된다. 또한 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체도 생성되어 지역 스코프에 등록된다. arguments 객체는 유사배열객체(Array-like Object)로, spread 연산자를 사용해서 배열로 만들어 사용할 수 있다.

  ##### 2. 코드의 실행

  코드의 평가 과정이 끝나면 선언문을 제외한 코드가 순차적으로 실행된다. 이 때 할당문 등 코드 실행에 필요한 정보를 실행 컨텍스트에서 가져온다. 코드의 실행 결과는 실행 컨텍스트에서 관리된다.

  코드 실행 중 식별자를 만나면 우선 해당 실행 컨텍스트의 스코프에서 검색하고, 없으면 전역 스코프까지 올라간다. console 같은 식별자의 경우 전역 스코프에 등록되지 않았다. 그러나 ReferenceError가 나지 않는다. 이는 **전역 스코프에서 식별자를 못 찾을 시 전역 객체의 프로퍼티를 검색하기 때문**이다. 전역 객체의 프로퍼티는 마치 전역 스코프에 등록된 식별자처럼 동작한다.

  #### 실행 컨텍스트의 역할

  ##### 1. 전역 코드 평가

  전역 코드를 한 줄씩 실행하기 이전에 전역 코드가 평가된다. 평가 과정에서 변수 선언문과 함수 선언문이 평가된다. 그 결과로 전역 변수와 전역 함수가 전역 스코프에 등록된다. **`var` 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티**가 된다. `let`이나 `const` 키워드로 선언된 전역 변수는 **전역 객체의 프로퍼티가 아니라 전역 스코프의 식별자로 등록**된다.

  ##### 2. 전역 코드 실행

  전역 코드 평가가 끝나면 전역 코드를 순차적으로 실행한다. 전역 변수에 값이 할당되고 함수가 호출된다. 함수가 호출되면 전역 코드의 실행이 멈추고 호출된 함수 내부로 진입한다.

  ##### 3. 함수 코드 평가

  함수 내부로 진입하면 함수 내부 코드를 실행하기 이전에 함수 코드가 평가된다. 이 때 parameter와 지역 변수 선언문이 평가된다. 그 결과로 parameter와 지역 변수는 지역 스코프에 등록된다. arguments 객체도 생성되어 스코프에 등록된다.

  ##### 4. 함수 코드 실행

  함수 코드가 순차적으로 실행되고 종료되면 함수를 빠져나와 함수 호출 다음의 전역 코드를 실행한다.

  

  결국 실행 컨텍스트가 해야하는 역할은 다음과 같다.

  1. 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분해서 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리해야 한다.
  2. 스코프 중첩 관계에 의해서 스코프 체인을 형성해야 한다. 스코프 체인을 통해서 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다.
  3. 함수 호출 등으로 현재 실행중인 코드의 실행 순서를 변경할 수 있어야 하며 다시 되돌아갈 수 있어야 한다.

  **실행 컨텍스트(Execution Context)는 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.**

  다시 말해, 실행 컨텍스트는 식별자(변수, 함수, 클래스, this 등)를 등록하고 관리하기 위한 **스코프와 실행 순서 관리를 구현한 내부 매커니즘**으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.

  #### 실행 컨텍스트 스택 (or Call Stack)

  ```javascript
  const x = 1;
  
  function foo() {
      const y = 2;
      function bar() {
          const z = 3;
          console.log(x + y + z);
      }
      bar();
  }
  
  foo();
  ```

  ##### **1. 전역 코드의 평가와 실행**

  자바스크립트 엔진은 자바스크립트 파일을 로드하고 실행하기 이전에 평가 과정을 거치며 전역 실행 컨텍스트를 생성한다. **전역 객체는 전역 실행 컨텍스트 이전에 생성**되어있다. 그러므로 전역 코드를 평가할 때 `var` 키워드 등으로 선언한 변수를 전역 객체의 프로퍼티로 추가할 수 있는 것이다. 전역 실행 컨텍스트는 생성되는 즉시 `실행 컨텍스트 스택`에 push된다. 이 때 전역 변수 x와 전역 함수 foo는 전역 실행 컨텍스트에 등록된다. 이후에 전역 코드가 실행되며 x에 값이 할당되고 foo가 호출된다.

  ##### 2. foo 함수의 평가와 실행

  전역 함수 foo가 호출되면 전역 코드의 실행이 멈추고 control이 foo 함수 내부로 이동한다. 자바스크립트 엔진은 foo 함수 내부의 함수 코드를 평가해서 foo 함수 실행 컨텍스트를 생성하고 `실행 컨텍스트 스택`에 push한다. foo 함수 평가가 끝나고 실행을 하다가 중첩 함수 bar를 만나면 bar를 호출한다.

  ##### 3. bar 함수의 평가와 실행

  중첩 함수 bar가 호출되면 foo 코드의 실행이 멈추고 control이 bar 함수 내부로 이동한다. 자바스크립트 엔진은 bar 함수 내부의 함수 코드를 평가해서 bar 함수 실행 컨텍스트를 생성하고 `실행 컨텍스트 스택`에 push한다. bar 함수는 실행을 마치고 종료한다.

  ##### 4. foo 함수 코드로 복귀

  ##### 5. 전역 코드로 복귀

  #### 렉시컬 환경

  **Lexical Environment는 식별자가 선언되는 환경,** 즉 **렉시컬 스코프**를 의미한다. 렉시컬 환경은 스코프와 식별자를 관리한다.

  ![img](https://poiemaweb.com/assets/fs-images/23-9.png)

  실행 컨텍스트는 LexicalEnvorinment 컴포넌트와 VariableEnvironment 컴포넌트로 구성된다. 생성 초기에 두 컴포넌트는 하나의 동일한 렉시컬 환경을 참조한다. with 문을 사용하지 않으면 둘은 언제나 동일한 렉시컬 환경을 참조한다.

  렉시컬 환경은 EnvironmentRecord 컴포넌트와 OuterLexicalEnvironmentReference 컴포넌트, thisBinding으로 구성된다.

  ![img](https://poiemaweb.com/assets/fs-images/23-10.png)

  

  1. EnvironmentRecord : 환경 레코드. 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소. 환경 레코드는 Executable Code의 종류에 따라 내용이 다르다. 예를 들어 전역 코드의 경우 전역 객체와 연결되어야하고 함수 코드는 그렇지 않다.
  2. Outer Lexical Enciromnent Reference : 외부 렉시컬 환경을 가리키는 참조를 저장. 해당 실행 컨텍스트를 생성한 Executable code를 포함하는 상위 코드의 렉시컬 환경을 말한다. 이를 통해서 One-way linked list인 스코프 체인을 구현한다.
  3. ThisBinding : this 바인딩. 렉시컬 환경의 this에 바인딩된 객체(ThisBinding)를 나타낸다. this 바인딩은 Abstract operation ResolveThisBinding을 통해 결정할 수 있다.

  결국 스코프 체인은 각 실행 컨텍스트의 Lexical Environment의 link로 구성된 Linked List이다.

  

* ### 클로저

  클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

  **렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 이것이 바로 렉시컬 스코프이다.**

  #### 함수 객체의 내부 슬롯 `[[Environment]]`

  함수 정의가 평가되어 함수 객체를 생성할 때, 자신이 정의된 환경(위치)에 의해 결정된 상위 스코프의 참조를 함수 객체 자신의 내부 슬롯 [[Environment]]에 저장한다. 이때 자신의 내부 슬롯 [[Environment]]에 저장된 상위 스코프의 참조는 **현재 실행 중인 실행 컨텍스트의 렉시컬 환경**을 가리킨다.

  outer 함수가 inner 함수를 리턴하며 종료될 때 실행 컨텍스트 스택에서 제거되어도 outer 함수의 렉시컬 환경은 소멸하지 않는다. inner 함수의 OuterLexicalEnvironmentReference로 outer 함수의 렉시컬 환경을 참조하고 있기 때문이다.

  클로저에 의해 참조되는 상위 스코프의 변수(위 예제의 경우, foo 함수의 변수 x)를 **자유 변수(Free variable)**라고 부른다. 클로저(closure)란 “함수가 자유 변수에 대해 닫혀있다(closed)”라는 의미이다.

  **클로저는 상태를 안전하게 유지하기 위해 사용한다**. 즉, 상태가 의도치 않게 변경되지 않도록 안전하게 **은닉(Information hiding)**한다. 그리고 이전 상태를 기억하다가 상태가 변경되면 **최신 상태(state)를 유지**한다.

  

* ### 브라우저 동작

  - 브라우저는 **동기(Synchronous)적**으로 HTML, CSS, 자바스크립트를 처리한다. 이것은 **script 태그의 위치**에 따라 블로킹이 발생하여 DOM의 생성이 지연될 수 있다는 것을 의미한다. 따라서 **script 태그의 위치는 중요한 의미를 갖는다.**
  - body 요소의 가장 아래에 script 태그를 위치시키면 **이미 HTML 파서가 HTML 요소를 모두 파싱하여 DOM 객체를 생성**하였기 때문에 자바스크립트가 **DOM 조작 시 에러가 발생하지 않는다.** 또한, HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 **페이지 로딩 시간이 단축**된다.

  ##### 웹 브라우저의 동작 순서

  1. 클라이언트가 서버에게 **Request(요청)**을 보낸다.
  2. 서버가 **Response(응답)**을 보낸다.
  3. 클라이언트가 서버의 응답을 받아서 HTML, CSS, JavaScript, 이미지 등의 파일을 **Load**한다.
  4. 렌더링 엔진의 HTML 파서와 CSS 파서가 HTML, CSS 파일을 파싱(Parsing) 한다.
     - 자바스크립트는 렌더링 엔진이 아닌 **자바스크립트 엔진**이 처리한다.
     - HTML 파서는 **script 태그**를 만나면 자바스크립트 코드를 실행하기 위해 **DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다.**
     - 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 **브라우저가 중지했던 시점**부터 DOM 생성을 재개한다.
  5. 파싱된 결과를 바탕으로 HTML은 **DOM tree**, CSS는 **CSSOM tree**, JavaScript는 **syntax tree**로 변환한다.
  6. 자바스크립트가 DOM tree와 CSSOM tree를 제어한다.
  7. DOM tree와 CSSOM tree가 **렌더 트리로 결합**된다.
  8. 생성된 렌더 트리를 기반으로 브라우저는 웹 페이지를 표시한다.

  

* ### Promise

  자바스크립트는 비동기 처리를 위해서 callback 함수 패턴을 사용한다. 그러나 callback 패턴은 가독성이 나쁘고 **에러의 예외 처리가 곤란**하다. ES6에서 Asynchronous processing을 위한 패턴으로 Promise를 도입했다.

  **Promise는 비동기 처리를 하고 Response가 오면 해야할 일을 약속하는 것**이다.

  #### 콜백 패턴의 단점

  1. 콜백 헬

     콜백 패턴을 사용할 때 처리 순서를 위해서 여러 개의 콜백 함수가 중첩되어 프로그래밍의 복잡도가 높아진다. 그래서 콜백 헬이 발생한다.

  2. 에러 처리의 한계

     Exception(예외)는 Caller 방향으로 전파되는데, 콜백 함수의 경우 Caller를 찾을 수 없으므로 try catch로 에러를 캐치할 수 없다.

  이러한 콜백의 단점을 보완하기 위해서 ES6에서 Promise를 도입했다.

  #### Promise 생성

  ```javascript
  const promise = new Promise((resolve, reject) => {
  	// Asynchronous process
  	if (/* Asynchronous process Fulilled */) {
          resolve('result');
      } else {
          /* Asynchronous process Rejected */
          reject('failure reason');
      }
  });
  ```

  Promise constructor function은 비동기 작업을 수행할 callback 함수를 argument로 전달받는다. 이 callback 함수는 resolve, reject 함수를 argument로 전달받는다.

  resolve 함수는 argument로 실행 결과를 전달하며 호출, reject 함수는 argument로 에러 메시지를 전달하며 호출한다.

  #### Promise 후속 처리

  비동기 함수는 Promise 객체를 리턴해야 한다. 그러면 Promise 객체의 메소드인 then과 catch를 사용해서 후속 처리를 한다.

  > #### then
  >
  > then 메소드는 두 개의 콜백 함수를 argument로 전달받는다. **첫 번째 callback 함수는 성공**(fulfilled, resolve 함수가 호출된 상태) 시 호출되고 **두 번째 callback은 실패**(rejected, reject 함수가 호출된 상태) 시 호출된다.
  >
  > ```
  >  p.then(onFulfilled, onRejected);
  >  p.then(function(value) {
  >  // fulfilled
  >  }, function(reason) {
  >  // rejected
  >  });
  > 
  > ```

  > ```
  > onFulfilled
  > ```
  >
  >  Promise가 성공했을 때 호출되는 function. **Fulfillment value** (수행 결과) (Promise의 resolve argument에 넘겨준 response) 하나를 argument로 받는다. Promise를 리턴한다.
  >
  > ```
  > onRejected
  > ```
  >
  >  Promise가 거부되었을 때 호출되는 function. **Rejected reason** (에러 이유) (Promise의 regect argument에 넘겨준 error mesagge) 하나를 argument로 받는다. Promise를 리턴한다.

  > #### catch
  >
  > **예외(비동기 처리에서 발생한 에러와 then 메소드에서 발생한 에러)가 발생하면 호출**된다.
  >
  > ```
  >  p.catch(onRejected);
  >  
  >  p.catch(function(reason) {
  >  // rejected
  >  });
  > ```

  > ```
  > onRejected
  > ```
  >
  >  Promise가 거부되었을 때 호출되는 function. Rejected reason을 argument로 받는다.

  then과 catch 메소드도 Promise 객체를 리턴하므로 Promise Chaining이 가능하다. 콜백을 중첩시키지 않고서도 처리 순서를 지킬 수 있다.

* ### JavaScript Event Loop

  동기식 처리 모델(Synchronous Processing Model)은 Blocking model이라고도 불리며, 어떤 작업 도중에 클라이언트가 서버에 데이터를 요청하는 것과 같이 시간이 오래 걸리는 일이 발생하면 다른 작업을 Blocking 시켜놓고 해당 작업이 끝날 때까지 기다리는 것과 같이 동작한다.

  반면 비동기식 처리 모델(Asynchronous Processing Model)은 작업 도중 서버로의 요청 등 시간이 오래 걸리는 일이 발생하면 기다리지 않고 (non-blocking) 바로 다음 작업을 실행한다.

  자바스크립트의 대부분의 DOM 이벤트와 Timer 함수(setTimeout, setInterval), Ajax 요청은 비동기식 처리 모델로 동작한다.

  

  **브라우저는 Single-thread에서 Event-driven 방식으로 동작한다.**

  #### Single-thread

  Single thread는 하나의 thread만을 사용하기 때문에 어느 한 순간에 하나의 task만을 처리할 수 있다는 것을 의미한다. 그러나 브라우저를 사용하는 사용자는 동시에 여러 웹 애플리케이션을 실행하고 있는 것처럼 느낄 것이다. **Event Loop**가 자바스크립트의 동시성(Concurrency)을 지원하기 때문이다.

  #### Call Stack

  스택은 LIFO(Last In First Out)으로 마지막에 들어온 task가 먼저 실행된다. 자바스크립트는 하나의 Call Stack을 사용한다. 이는 어떤 task가 종료하기 전에 다른 task는 수행될 수 없음을 의미한다.

  #### Heap

  Dynamic하게 생성된 Object Instance가 할당되는 영역

  #### Event Queue(Task Queue)

  Asynchronous process function의 callback 함수, asynchronous event handler, Timer 함수의 callback 함수가 보관되는 영역.

  Event Loop에 의해 Call Stack이 비었을 때 순차적으로 Call Stack으로 이동해서 실행된다.

  이벤트 발생시 이벤트 핸들러는 Event Queue에 들어갔다가 Call Stack이 비면 Event Loop에 의해서 Call Stack에 진입해 실행된다.

  #### Event Loop

  Event Loop는 Call Stack의 task와 Event Queue의 task를 주기적으로 확인한다. Call Stack이 비어있는 시점에 Event Queue 내의 Task를 Call Stcak으로 이동시켜 실행하게 한다.

  Event Loop가 빠르게 돌며 task를 순간순간 전환하기 때문에 사용자는 여러개의 task를 동시에 실행하고 있다고 느끼는 것이다. 이렇게 한 번에 하나의 task을 처리하면서 마치 동시에 처리하는 것처럼 동작시키는 방법을 Pseudo Parallel이라고 한다.

  [![event-loop](https://poiemaweb.com/img/event-loop.gif)](https://poiemaweb.com/img/event-loop.gif)

#### 추가 자료

- [JavaScript 기본서 비교](http://asfirstalways.tistory.com/246)
- [ECMAScript6 정리](https://jaeyeophan.github.io/categories/ECMAScript6)
- Interview Algorithm Questions in JavaScript (영어)
  - JavaScript 와 관련된 인터뷰 관련 내용들을 정리해놓은 자료입니다.

# Part 3. 분야별

## 🔶 Front-End [Link](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/FrontEnd)

- ### 브라우저의 작동 원리

  - HTML 마크업을 처리하고 DOM 트리를 빌드한다. (**"무엇을"** 그릴지 결정한다.)
  - CSS 마크업을 처리하고 CSSOM 트리를 빌드한다. (**"어떻게"** 그릴지 결정한다.)
  - DOM 및 CSSOM 을 결합하여 렌더링 트리를 형성한다. (**"화면에 그려질 것만"** 결정)
  - 렌더링 트리에서 레이아웃을 실행하여 각 노드의 기하학적 형태를 계산한다. (**"Box-Model"** 을 생성한다.)
  - 개별 노드를 화면에 페인트한다.(or 래스터화)

  

- ### Document Object Model

  #### Event Bubbling and Capturing

  - Event Capturing : 자식 요소에서 발생한 이벤트가 부모 요소부터 시작하여 이벤트를 발생시킨 자식 요소까지 도달하는 것
  - Event Bubbling : 자식 요소에서 발생한 이벤트가 부모 요소로 전파되는 것

  **주의할 것은 버블링과 캡처링은 둘 중에 하나만 발생하는 것이 아니라 캡처링부터 시작하여 버블링으로 종료한다는 것이다.** 즉, 이벤트가 발생했을 때 캡처링과 버블링은 순차적으로 발생한다.

  #### Event delegation(이벤트 위임)

  여러 child element의 이벤트를 캐치하고 싶을 때 이벤트 위임을 이용해서 parent element에 이벤트 핸들러를 바인딩한다.

  또한 어떤 ul element에 동적으로 child li element들이 추가되는 경우, 동적으로 추가되는 element는 DOM에 아직 존재하지 않으므로 이벤트 핸들러를 바인딩할 수 없다. 이런 경우에도 parent element인 ul에 이벤트 핸들러를 바인딩해 event elegation을 사용한다.

  **이벤트 위임(Event Delegation)은 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신 하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법**이다.

  Event Delegation은 이벤트가 Event flow에 의해서 bubbling이 되기 때문에 가능한 것이다.

  실제로 이벤트를 발생시킨 element는 event.target으로 찾는다.

  

- ### CORS

  다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 **cross-origin HTTP 요청** 에 의해 요청된다. 하지만 대부분의 브라우저들은 보안 상의 이유로 스크립트에서의 cross-origin HTTP 요청을 제한한다. 이것을 `Same-Origin-Policy(동일 근원 정책)`이라고 한다. 요청을 보내기 위해서는 요청을 보내고자 하는 대상과 프로토콜도 같아야 하고, 포트도 같아야 함을 의미한다.*(이 때, 서브 도메인 네임은 상관없다.)*

  이러한 문제를 해결하기 위해 과거에는 flash 를 proxy 로 두고 타 도메인간 통신을 했다. 하지만 모바일 운영체제의 등장으로 flash 로는 힘들어졌다. (iOS 는 전혀 플래시를 지원하지 않는다.) 대체제로 나온 기술이 `JSONP(JSON-padding)`이다. jQuery v.1.2 이상부터 `jsonp`형태가 지원되 ajax 를 호출할 때 타 도메인간 호출이 가능해졌다. `JSONP`에는 타 도메인간 자원을 공유할 수 있는 몇 가지 태그가 존재한다. 예를들어 `img`, `iframe`, `anchor`, `script`, `link` 등이 존재한다.

  여기서 `CORS`는 타 도메인 간에 자원을 공유할 수 있게 해주는 것이다. `Cross-Origin Resource Sharing` 표준은 웹 브라우저가 사용하는 정보를 읽을 수 있도록 허가된 **출처 집합**을 서버에게 알려주도록 허용하는 특정 HTTP 헤더를 추가함으로써 동작한다.

  | HTTP Header                      | Description                    |
  | -------------------------------- | ------------------------------ |
  | Access-Control-Allow-Origin      | 접근 가능한 `url` 설정         |
  | Access-Control-Allow-Credentials | 접근 가능한 `쿠키` 설정        |
  | Access-Control-Allow-Headers     | 접근 가능한 `헤더` 설정        |
  | Access-Control-Allow-Methods     | 접근 가능한 `http method` 설정 |



- #### 크로스 브라우징

  웹 표준에 따라 개발을 하여 서로 다른 OS 또는 플랫폼에 대응하는 것을 말한다. 즉, 브라우저의 렌더링 엔진이 다른 경우에 인터넷이 이상없이 구현되도록 하는 기술이다. 웹 사이트를 서로 비슷하게 만들어 어떤 **환경** 에서도 이상없이 작동되게 하는데 그 목적이 있다. 즉, 어느 한쪽에 최적화되어 치우치지 않도록 공통요소를 사용하여 웹 페이지를 제작하는 방법을 말한다.

  

- 서버 사이드 렌더링 vs 클라이언트 사이드 렌더링

- CSS Methodology

- ### normalize.css vs reset.css

  브라우저마다 기본적으로 제공하는 element 의 style 을 통일시키기 위해 사용하는 두 `css`에 대해 알아본다.

  #### reset.css

  `reset.css`는 기본적으로 **제공되는 브라우저 스타일 전부를 제거 하기 위해 사용**된다. `reset.css`가 적용되면 `<H1>~<H6>`, `<p>`, `<strong>`, `<em>` 등 과 같은 표준 요소는 완전히 똑같이 보이며 브라우저가 제공하는 기본적인 styling 이 전혀 없다.

  #### normalize.css

  `normalize.css`는 브라우저 간 일관된 스타일링을 목표로 한다. `<H1>~<H6>`과 같은 요소는 브라우저간에 일관된 방식으로 굵게 표시된다. 추가적인 디자인에 필요한 style 만 CSS 로 작성해주면 된다.

  즉, `normalize.css`는 모든 것을 "해제"하기보다는 유용한 기본값을 보존하는 것이다. 예를 들어, sup 또는 sub 와 같은 요소는 `normalize.css`가 적용된 후 바로 기대하는 스타일을 보여준다. 반면 `reset.css`를 포함하면 시각적으로 일반 텍스트와 구별 할 수 없다. 또한 normalize.css 는 reset.css 보다 넓은 범위를 가지고 있으며 HTML5 요소의 표시 설정, 양식 요소의 글꼴 상속 부족, pre-font 크기 렌더링 수정, IE9 의 SVG 오버플로 및 iOS 의 버튼 스타일링 버그 등에 대한 이슈를 해결해준다.

#### 추가 자료

- [신입 프론트엔드 개발자가 되려면 무엇을 학습해야 하나요?](https://jbee.io/essay/for_junior_frontend_developer/)
- [Front-end Developer Interview Questions (한국어)](https://h5bp.org/Front-end-Developer-Interview-Questions/translations/korean/)
- [Front-end Interview (영어)](http://thatjsdude.com/interview/index.html)
- Front-end Checklist
  - 면접 시 물어보기 가장 좋은 것들이 '기본'에 대한 내용이라고 생각되는데요, 그 '기본'에 대해 체크리스트 형식으로 잘 정리되어 있는 문서를 공유합니다.
- [Front End Interview Handbook (한국어)](https://github.com/yangshun/front-end-interview-handbook/tree/master/Translations/Korean)
- [React 구조에 대한 고민 시리즈](https://jbee.io/react/react-0-intro/)

1. List, Set, Map

   - List: 인덱스로 데이터 접근
   - Set: 중복되는 데이터 없이 데이터로만 이루어짐
   - Map: key와 value로 데이터 저장

2. CORS가 무엇이고 해결법은?

   다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 **cross-origin HTTP 요청** 에 의해 요청된다. 하지만 대부분의 브라우저들은 보안 상의 이유로 스크립트에서의 cross-origin HTTP 요청을 제한한다. 이것을 `Same-Origin-Policy(동일 근원 정책)`이라고 한다

   proxy를 사용하거나 PreflightHeader를 미리 보내서 서버의 승인을 받으면 그 후에 요청을 보내는 방식으로 해결할 수 있다.

3. 자바스크립트가 Hoisting이 되도록 설계된 이유를 생각해봤는가?

   다시 생각해보니까 자바스크립트는 초기에 브라우저 환경을 위해 개발된 언어로, 브라우저 런타임에 에러가 나지 않도록 최대한 에러를 줄이는 방식으로 디자인된 것 같다. 선언문 이전에 변수를 참조해도 에러를 내지 않고 `var` 키워드 없이 변수를 선언해도 전역변수의 프로퍼티로 등록하는 등 에러를 최소화한 이유는 브라우저가 멈추지 않기 하기 위해서인 것 같다.